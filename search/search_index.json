{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur ma page github ! For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#bienvenue-sur-ma-page-github","text":"For full documentation visit mkdocs.org .","title":"Bienvenue sur ma page github !"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"java/awt/customcomponents/","text":"Composants customis\u00e9s Avant de s'atarder sur la cr\u00e9ation de composants customis\u00e9s, revenons sur les notions de : Panel Frame Window Panel Panel est un composant qui permet de placer plusieurs composants dessus. Un Panel peut donc contenir d'autres Panel. Frame Frame est un composant qui fonctionne comme la fen\u00eatre principale de l\u2019application graphique. Il est cr\u00e9\u00e9 en utilisant la classe Frame. Pour toute application graphique, la premi\u00e8re \u00e9tape consiste \u00e0 cr\u00e9er un cadre. Il existe deux m\u00e9thodes pour cr\u00e9er un cadre: en \u00e9tendant la classe Frame ou en cr\u00e9ant un objet de la classe Frame. Diff\u00e9rences entre Frame et Panel Le Panel n\u00e9cessite une Frame pour l'afficher. Une Frame, elle, peut \u00eatre constitu\u00e9e d'un Panel ou d'un ensemble de Panel. Les diff\u00e9rences principales sont : La hi\u00e9rarchie de classe : Panel est une sous-classe de Container , alors que Frame est une sous-classe de Window (qui eest une sous-classe de Container ). Barre de titre : Panel n'a pas de barre de titre contrairement \u00e0 Frame. Fronti\u00e8re : Panel n'a pas de bordure contrairement \u00e0 Frame. Layouts par d\u00e9faut : Panel utilise FlowLayout par d\u00e9faut, contrairement \u00e0 Frame qui utilise BorderLayout par d\u00e9faut. Cr\u00e9ation d'un nouveau composant Il est possible de d\u00e9finir de nouveaux composants qui h\u00e9ritent directement de Panel : FlowLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class PanneauClavier extends Panel { public PanneauClavier () { this . setLayout ( new GridLayout ( 4 , 3 )); for ( int num = 1 ; num <= 9 ; num ++ ) { this . add ( new Button ( Integer . toString ( num ))); } this . add ( new Button ( \"*\" ); this . add ( new Button ( \"0\" ); this . add ( new Button ( \"# \" ); } } public class demo extends Applet { public void init () { this . add ( new PanneauClavier ()); } }","title":"Composants customis\u00e9s"},{"location":"java/awt/customcomponents/#composants-customises","text":"Avant de s'atarder sur la cr\u00e9ation de composants customis\u00e9s, revenons sur les notions de : Panel Frame Window","title":"Composants customis\u00e9s"},{"location":"java/awt/customcomponents/#panel","text":"Panel est un composant qui permet de placer plusieurs composants dessus. Un Panel peut donc contenir d'autres Panel.","title":"Panel"},{"location":"java/awt/customcomponents/#frame","text":"Frame est un composant qui fonctionne comme la fen\u00eatre principale de l\u2019application graphique. Il est cr\u00e9\u00e9 en utilisant la classe Frame. Pour toute application graphique, la premi\u00e8re \u00e9tape consiste \u00e0 cr\u00e9er un cadre. Il existe deux m\u00e9thodes pour cr\u00e9er un cadre: en \u00e9tendant la classe Frame ou en cr\u00e9ant un objet de la classe Frame.","title":"Frame"},{"location":"java/awt/customcomponents/#differences-entre-frame-et-panel","text":"Le Panel n\u00e9cessite une Frame pour l'afficher. Une Frame, elle, peut \u00eatre constitu\u00e9e d'un Panel ou d'un ensemble de Panel. Les diff\u00e9rences principales sont : La hi\u00e9rarchie de classe : Panel est une sous-classe de Container , alors que Frame est une sous-classe de Window (qui eest une sous-classe de Container ). Barre de titre : Panel n'a pas de barre de titre contrairement \u00e0 Frame. Fronti\u00e8re : Panel n'a pas de bordure contrairement \u00e0 Frame. Layouts par d\u00e9faut : Panel utilise FlowLayout par d\u00e9faut, contrairement \u00e0 Frame qui utilise BorderLayout par d\u00e9faut.","title":"Diff\u00e9rences entre Frame et Panel"},{"location":"java/awt/customcomponents/#creation-dun-nouveau-composant","text":"Il est possible de d\u00e9finir de nouveaux composants qui h\u00e9ritent directement de Panel : FlowLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class PanneauClavier extends Panel { public PanneauClavier () { this . setLayout ( new GridLayout ( 4 , 3 )); for ( int num = 1 ; num <= 9 ; num ++ ) { this . add ( new Button ( Integer . toString ( num ))); } this . add ( new Button ( \"*\" ); this . add ( new Button ( \"0\" ); this . add ( new Button ( \"# \" ); } } public class demo extends Applet { public void init () { this . add ( new PanneauClavier ()); } }","title":"Cr\u00e9ation d'un nouveau composant"},{"location":"java/awt/layouts/","text":"Les Layouts Les layouts d\u00e9signent la disposition des composants dans le conteneur. En d'autres termes, nous pouvons dire qu'il s'agit de placer les composants \u00e0 une position particuli\u00e8re dans le conteneur. La t\u00e2che de mise en page des contr\u00f4les est effectu\u00e9e automatiquement par le Layout Manager. Le gestionnaire de mise en page positionne automatiquement tous les composants \u00e0 l'int\u00e9rieur du conteneur. Si nous n'utilisons pas le gestionnaire de disposition, les composants sont \u00e9galement positionn\u00e9s par le gestionnaire de disposition par d\u00e9faut. Il est possible de positionner les contr\u00f4les \u00e0 la main mais cela devient tr\u00e8s difficile pour les deux raisons suivantes : Il est tr\u00e8s fastidieux de manipuler un grand nombre de contr\u00f4les dans le conteneur. Souvent, les informations relatives \u00e0 la largeur et \u00e0 la hauteur d'un composant ne sont pas fournies lorsque nous avons besoin de les agencer. Java nous fournit divers gestionnaires de mise en page pour positionner les contr\u00f4les. Les propri\u00e9t\u00e9s telles que la taille, la forme et la disposition varient d'un gestionnaire de disposition \u00e0 l'autre. Lorsque la taille de l'applet ou de la fen\u00eatre d'application change, la taille, la forme et la disposition des composants changent \u00e9galement en r\u00e9ponse, c'est-\u00e0-dire que les gestionnaires de disposition s'adaptent aux dimensions de l'appletviewer ou de la fen\u00eatre d'application. Le gestionnaire de mise en page est associ\u00e9 \u00e0 chaque objet issus de la classe Container . Chaque gestionnaire de disposition est un objet de la classe qui impl\u00e9mente l'interface LayoutManager . FlowLayout Il s'agit du LayoutManager par d\u00e9faut des applets. Il place les composants ligne par ligne de gauche \u00e0 droite . Chaque ligne est compl\u00e9t\u00e9e progressivement avant de passer \u00e0 la suivante. Constructeur R\u00f4le FlowLayout() Cr\u00e9ation d'un flow layout avec un alignement CENTER et un espacement horizontal/vertical de 5. FlowLayout(int align) Permet de pr\u00e9ciser l'alignement des composants dans le conteneur (CENTER, LEFT, RIGHT ... ) FlowLayout( int align, int hgap, int vgap) Permet de pr\u00e9ciser l'alignement et l'espacement horizontal et vertical FlowLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class CustomFrame extends Frame { public CustomFrame () { super (); this . setTitle ( \" Titre de la Fenetre \" ); this . setSize ( 300 , 150 ); this . setLayout ( new FlowLayout ()); this . add ( new Button ( \"Bouton 1\" )); this . add ( new Button ( \"Bouton 2\" )); this . add ( new Button ( \"Bouton 3\" )); this . pack (); this . show (); } public static void main ( String [] args ) { new CustomFrame (); } } R\u00e9sultat Fen\u00eatre redimensionn\u00e9e : BorderLayout Ce LayoutManager d\u00e9coupe la surface en 5 zones : North, South, East, West, Center. Le composant du milieu dispose de la place non utilis\u00e9e par les 4 autres composants. Constructeur R\u00f4le BorderLayout() - BorderLayout(int hgap,int vgap) Permet de pr\u00e9ciser l'espacement horizontal et vertical des composants. BorderLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class CustomFrame extends Frame { public CustomFrame () { this . super (); this . setTitle ( \" Titre de la Fenetre \" ); this . setSize ( 300 , 150 ); // Border Layout this . setLayout ( new BorderLayout ()); // Placement des composants this . add ( new Button ( \"bouton haut\" ), BorderLayout . NORTH ); this . add ( new Button ( \"bouton bas\" ), BorderLayout . SOUTH ); this . add ( new Button ( \"bouton gauche\" ), BorderLayout . WEST ); this . add ( new Button ( \"bouton droite\" ), BorderLayout . EAST ); this . add ( new Button ( \"bouton milieu\" ), BorderLayout . CENTER ); this . pack (); this . show (); } public static void main ( String [] args ) { new CustomFrame (); } } R\u00e9sultat CardLayout Ce LayoutManager aide \u00e0 construire des bo\u00eetes de dialogue compos\u00e9es de plusieurs onglets. Un onglet se compose g\u00e9n\u00e9ralement de plusieurs contr\u00f4les : on ins\u00e8re des panneaux dans la fen\u00eatre utilis\u00e9e par le CardLayout Manager. Chaque panneau correspond \u00e0 un onglet de bo\u00eete de dialogue et contient plusieurs contr\u00f4les. Par d\u00e9faut, c'est le premier onglet qui est affich\u00e9. Constructeur R\u00f4le CardLayout() - CardLayout(int hgap,int vgap) Permet de pr\u00e9ciser l'espacement horizontal et vertical des composants. CardLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class CustomFrame extends Frame { public CustomFrame () { super (); this . setTitle ( \"Titre de la Fenetre \" ); this . setSize ( 300 , 150 ); CardLayout cardLayout = new CardLayout (); this . setLayout ( cardLayout ); // Cr\u00e9ation d'un panneau contenant les contr\u00f4les d'un onglet Panel panel = new Panel (); // Ajouter les composants au panel panel . add ( new Button ( \"Bouton 1 panneau 1\" )); panel . add ( new Button ( \"Bouton 2 panneau 1\" )); // Inclure le panneau dans la fenetre sous le nom \"Page1\" : Il s'agit du premier onglet affich\u00e9 par d\u00e9faut. this . add ( \"Page1\" , panel ); // D\u00e9claration et insertion de l'onglet suivant panel = new Panel (); panel . add ( new Button ( \"Bouton 1 panneau 2\" )); this . add ( \"Page2\" , panel ); pack (); show (); } public static void main ( String [] args ) { new CustomFrame (); } } R\u00e9sultat Lors de l'insertion d'un onglet, un nom doit lui \u00eatre attribu\u00e9. Les fonctions n\u00e9cessaires pour afficher un onglet de bo\u00eete de dialogue ne sont pas fournies par les m\u00e9thodes du conteneur, mais seulement par le Layout Manager. Il est n\u00e9cessaire de sauvegarder temporairement le Layout Manager dans une variable o\u00f9 d\u00e9terminer le gestionnaire en cours par un appel \u00e0 getLayout(). Pour appeler un onglet donn\u00e9, il faut utiliser la m\u00e9thode show() du CardLayout Manager. CardLayout Code 1 (( CardLayout ) getLayout ()). show ( this , \"Page2\" ); R\u00e9sultat Note Les m\u00e9thodes first() , last() , next() et previous() servent \u00e0 parcourir les onglets de bo\u00eete de dialogue. 1 (( CardLayout ) getLayout ()). first ( this ); GridLayout Ce LayoutManager \u00e9tablit un r\u00e9seau de cellules identiques qui forment une sorte de quadrillage invisible : les composants sont organis\u00e9s en lignes et en colonnes. Les \u00e9l\u00e9ments ins\u00e9r\u00e9s dans la grille ont tous la m\u00eame taille. Les cellules du quadrillage se remplissent de gauche \u00e0 droite ou de haut en bas. Constructeur R\u00f4le GridLayout(int columns, int rows) Les deux premiers entiers sp\u00e9cifient le nombre de lignes ou de colonnes de la grille. GridLayout(int columns, int rows, int hgap, int vgap) permet de pr\u00e9ciser en plus l'espacement horizontal et vertical des composants. GridLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class CustomFrame extends Frame { public CustomFrame () { super (); this . setTitle ( \"Titre de la Fenetre \" ); this . setSize ( 300 , 150 ); setLayout ( new GridLayout ( 2 , 3 )); this . add ( new Button ( \"bouton 1\" )); this . add ( new Button ( \"bouton 2\" )); this . add ( new Button ( \"bouton 3\" )); this . add ( new Button ( \"bouton 4\" )); this . add ( new Button ( \"bouton 5 tres long\" )); this . add ( new Button ( \"bouton 6\" )); pack (); show (); } public static void main ( String [] args ) { new CustomFrame (); } } R\u00e9sultat GridBagLayout Ce gestionnaire (grille \u00e9tendue) est le plus riche en fonctionnalit\u00e9s : le conteneur est divis\u00e9 en cellules \u00e9gales mais un composant peut occuper plusieurs cellules de la grille et il est possible de faire une distribution dans des cellules distinctes. Un objet de la classe GridBagConstraints permet de donner les indications de positionnement et de dimension \u00e0 l'objet GridBagLayout. Les lignes et les colonnes prennent naissance au moment o\u00f9 les contr\u00f4les sont ajout\u00e9s. Chaque contr\u00f4le est associ\u00e9 \u00e0 un objet de la classe GridBagConstraints qui indique l'emplacement voulu pour le contr\u00f4le. 1 2 GridBagLayout gridBagLayout = new GridBagLayout (); GridBagConstraints gridBagConstraints = new GridBagConstraints (); L'objet GridBagConstraints peut \u00eatre manipul\u00e9 via les variables : Variable R\u00f4le gridx et gridy Ces variables contiennent les coordonn\u00e9es de l'origine de la grille. Elles permettent un positionnement pr\u00e9cis \u00e0 une certaine position d'un composant. Par d\u00e9faut elles ont la valeur GrigBagConstraint.RELATIVE qui indique qu'un composant se range \u00e0 droite du pr\u00e9c\u00e9dent. gridwidth, gridheight D\u00e9finissent combien de cellules va occuper le composant (en hauteur et largeur). Par d\u00e9faut la valeur est 1. L'indication est relative aux autres composants de la ligne ou de la colonne. La valeur GridBagConstraints.REMAINDER sp\u00e9cifie que le prochain composant ins\u00e9r\u00e9 sera le dernier de la ligne ou de la colonne courante. La valeur GridBagConstraints.RELATIVE place le composant apr\u00e8s le dernier composant d'une ligne ou d'une colonne. fill D\u00e9finit le sort d'un composant plus petit que la cellule de la grille. GridBagConstraints.NONE conserve la taille d'origine : valeur par d\u00e9faut GridBagConstraints.HORIZONTAL dilat\u00e9 horizontalement GridBagConstraints.VERTICAL dilat\u00e9 verticalement GridBagConstraints.BOTH dilat\u00e9s aux dimensions de la cellule. ipadx, ipady Permettent de d\u00e9finir l'agrandissement horizontal et vertical des composants. Ne fonctionne que si une dilatation est demand\u00e9e par fill. La valeur par d\u00e9faut est (0,0). anchor Lorsqu'un composant est plus petit que la cellule dans laquelle il est ins\u00e9r\u00e9, il peut \u00eatre positionn\u00e9 \u00e0 l'aide de cette variable pour d\u00e9finir le c\u00f4t\u00e9 par lequel le contr\u00f4le doit \u00eatre align\u00e9 dans la cellule. Les variables possibles sont NORTH, NORTHWEST, NORTHEAST, SOUTH, SOUTHWEST, SOUTHEAST, WEST et EAST. weightx, weighty Permettent de d\u00e9finir la r\u00e9partition de l'espace en cas de changement de dimension. GridBagLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class CustomFrame extends Frame { public CustomFrame () { super (); this . setTitle ( \"Titre de la Fenetre \" ); this . setSize ( 300 , 150 ); Button b1 = new Button ( \" bouton 1 \" ); Button b2 = new Button ( \" bouton 2 \" ); Button b3 = new Button ( \" bouton 3 \" ); GridBagLayout gridBagLayout = new GridBagLayout (); GridBagConstraints gridBagConstraints = new GridBagConstraints (); this . setLayout ( gridBagLayout ); // Propri\u00e9t\u00e9s du GridBadConstraints gridBagConstraints . fill = GridBagConstraints . BOTH ; gridBagConstraints . weightx = 1 ; gridBagConstraints . weighty = 1 ; // Mise en forme des objets gridBagLayout . setConstraints ( b1 , gridBagConstraints ); gridBagLayout . setConstraints ( b2 , gridBagConstraints ); gridBagLayout . setConstraints ( b3 , gridBagConstraints ); this . add ( b1 ); this . add ( b2 ); this . add ( b3 ); pack (); show (); } public static void main ( String [] args ) { new CustomFrame (); } } R\u00e9sultat Cet exemple place trois boutons l'un \u00e0 cot\u00e9 de l'autre. Ceci permet en cas de changement de dimension du conteneur de conserver la mise en page : la taille des composants est automatiquement ajust\u00e9e. Pour placer les 3 boutons l'un au-dessus de l'autre, il faut affecter la valeur 1 \u00e0 la variable gbc.gridx :","title":"Les layouts"},{"location":"java/awt/layouts/#les-layouts","text":"Les layouts d\u00e9signent la disposition des composants dans le conteneur. En d'autres termes, nous pouvons dire qu'il s'agit de placer les composants \u00e0 une position particuli\u00e8re dans le conteneur. La t\u00e2che de mise en page des contr\u00f4les est effectu\u00e9e automatiquement par le Layout Manager. Le gestionnaire de mise en page positionne automatiquement tous les composants \u00e0 l'int\u00e9rieur du conteneur. Si nous n'utilisons pas le gestionnaire de disposition, les composants sont \u00e9galement positionn\u00e9s par le gestionnaire de disposition par d\u00e9faut. Il est possible de positionner les contr\u00f4les \u00e0 la main mais cela devient tr\u00e8s difficile pour les deux raisons suivantes : Il est tr\u00e8s fastidieux de manipuler un grand nombre de contr\u00f4les dans le conteneur. Souvent, les informations relatives \u00e0 la largeur et \u00e0 la hauteur d'un composant ne sont pas fournies lorsque nous avons besoin de les agencer. Java nous fournit divers gestionnaires de mise en page pour positionner les contr\u00f4les. Les propri\u00e9t\u00e9s telles que la taille, la forme et la disposition varient d'un gestionnaire de disposition \u00e0 l'autre. Lorsque la taille de l'applet ou de la fen\u00eatre d'application change, la taille, la forme et la disposition des composants changent \u00e9galement en r\u00e9ponse, c'est-\u00e0-dire que les gestionnaires de disposition s'adaptent aux dimensions de l'appletviewer ou de la fen\u00eatre d'application. Le gestionnaire de mise en page est associ\u00e9 \u00e0 chaque objet issus de la classe Container . Chaque gestionnaire de disposition est un objet de la classe qui impl\u00e9mente l'interface LayoutManager .","title":"Les Layouts"},{"location":"java/awt/layouts/#flowlayout","text":"Il s'agit du LayoutManager par d\u00e9faut des applets. Il place les composants ligne par ligne de gauche \u00e0 droite . Chaque ligne est compl\u00e9t\u00e9e progressivement avant de passer \u00e0 la suivante. Constructeur R\u00f4le FlowLayout() Cr\u00e9ation d'un flow layout avec un alignement CENTER et un espacement horizontal/vertical de 5. FlowLayout(int align) Permet de pr\u00e9ciser l'alignement des composants dans le conteneur (CENTER, LEFT, RIGHT ... ) FlowLayout( int align, int hgap, int vgap) Permet de pr\u00e9ciser l'alignement et l'espacement horizontal et vertical FlowLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class CustomFrame extends Frame { public CustomFrame () { super (); this . setTitle ( \" Titre de la Fenetre \" ); this . setSize ( 300 , 150 ); this . setLayout ( new FlowLayout ()); this . add ( new Button ( \"Bouton 1\" )); this . add ( new Button ( \"Bouton 2\" )); this . add ( new Button ( \"Bouton 3\" )); this . pack (); this . show (); } public static void main ( String [] args ) { new CustomFrame (); } } R\u00e9sultat Fen\u00eatre redimensionn\u00e9e :","title":"FlowLayout"},{"location":"java/awt/layouts/#borderlayout","text":"Ce LayoutManager d\u00e9coupe la surface en 5 zones : North, South, East, West, Center. Le composant du milieu dispose de la place non utilis\u00e9e par les 4 autres composants. Constructeur R\u00f4le BorderLayout() - BorderLayout(int hgap,int vgap) Permet de pr\u00e9ciser l'espacement horizontal et vertical des composants. BorderLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class CustomFrame extends Frame { public CustomFrame () { this . super (); this . setTitle ( \" Titre de la Fenetre \" ); this . setSize ( 300 , 150 ); // Border Layout this . setLayout ( new BorderLayout ()); // Placement des composants this . add ( new Button ( \"bouton haut\" ), BorderLayout . NORTH ); this . add ( new Button ( \"bouton bas\" ), BorderLayout . SOUTH ); this . add ( new Button ( \"bouton gauche\" ), BorderLayout . WEST ); this . add ( new Button ( \"bouton droite\" ), BorderLayout . EAST ); this . add ( new Button ( \"bouton milieu\" ), BorderLayout . CENTER ); this . pack (); this . show (); } public static void main ( String [] args ) { new CustomFrame (); } } R\u00e9sultat","title":"BorderLayout"},{"location":"java/awt/layouts/#cardlayout","text":"Ce LayoutManager aide \u00e0 construire des bo\u00eetes de dialogue compos\u00e9es de plusieurs onglets. Un onglet se compose g\u00e9n\u00e9ralement de plusieurs contr\u00f4les : on ins\u00e8re des panneaux dans la fen\u00eatre utilis\u00e9e par le CardLayout Manager. Chaque panneau correspond \u00e0 un onglet de bo\u00eete de dialogue et contient plusieurs contr\u00f4les. Par d\u00e9faut, c'est le premier onglet qui est affich\u00e9. Constructeur R\u00f4le CardLayout() - CardLayout(int hgap,int vgap) Permet de pr\u00e9ciser l'espacement horizontal et vertical des composants. CardLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class CustomFrame extends Frame { public CustomFrame () { super (); this . setTitle ( \"Titre de la Fenetre \" ); this . setSize ( 300 , 150 ); CardLayout cardLayout = new CardLayout (); this . setLayout ( cardLayout ); // Cr\u00e9ation d'un panneau contenant les contr\u00f4les d'un onglet Panel panel = new Panel (); // Ajouter les composants au panel panel . add ( new Button ( \"Bouton 1 panneau 1\" )); panel . add ( new Button ( \"Bouton 2 panneau 1\" )); // Inclure le panneau dans la fenetre sous le nom \"Page1\" : Il s'agit du premier onglet affich\u00e9 par d\u00e9faut. this . add ( \"Page1\" , panel ); // D\u00e9claration et insertion de l'onglet suivant panel = new Panel (); panel . add ( new Button ( \"Bouton 1 panneau 2\" )); this . add ( \"Page2\" , panel ); pack (); show (); } public static void main ( String [] args ) { new CustomFrame (); } } R\u00e9sultat Lors de l'insertion d'un onglet, un nom doit lui \u00eatre attribu\u00e9. Les fonctions n\u00e9cessaires pour afficher un onglet de bo\u00eete de dialogue ne sont pas fournies par les m\u00e9thodes du conteneur, mais seulement par le Layout Manager. Il est n\u00e9cessaire de sauvegarder temporairement le Layout Manager dans une variable o\u00f9 d\u00e9terminer le gestionnaire en cours par un appel \u00e0 getLayout(). Pour appeler un onglet donn\u00e9, il faut utiliser la m\u00e9thode show() du CardLayout Manager. CardLayout Code 1 (( CardLayout ) getLayout ()). show ( this , \"Page2\" ); R\u00e9sultat Note Les m\u00e9thodes first() , last() , next() et previous() servent \u00e0 parcourir les onglets de bo\u00eete de dialogue. 1 (( CardLayout ) getLayout ()). first ( this );","title":"CardLayout"},{"location":"java/awt/layouts/#gridlayout","text":"Ce LayoutManager \u00e9tablit un r\u00e9seau de cellules identiques qui forment une sorte de quadrillage invisible : les composants sont organis\u00e9s en lignes et en colonnes. Les \u00e9l\u00e9ments ins\u00e9r\u00e9s dans la grille ont tous la m\u00eame taille. Les cellules du quadrillage se remplissent de gauche \u00e0 droite ou de haut en bas. Constructeur R\u00f4le GridLayout(int columns, int rows) Les deux premiers entiers sp\u00e9cifient le nombre de lignes ou de colonnes de la grille. GridLayout(int columns, int rows, int hgap, int vgap) permet de pr\u00e9ciser en plus l'espacement horizontal et vertical des composants. GridLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class CustomFrame extends Frame { public CustomFrame () { super (); this . setTitle ( \"Titre de la Fenetre \" ); this . setSize ( 300 , 150 ); setLayout ( new GridLayout ( 2 , 3 )); this . add ( new Button ( \"bouton 1\" )); this . add ( new Button ( \"bouton 2\" )); this . add ( new Button ( \"bouton 3\" )); this . add ( new Button ( \"bouton 4\" )); this . add ( new Button ( \"bouton 5 tres long\" )); this . add ( new Button ( \"bouton 6\" )); pack (); show (); } public static void main ( String [] args ) { new CustomFrame (); } } R\u00e9sultat","title":"GridLayout"},{"location":"java/awt/layouts/#gridbaglayout","text":"Ce gestionnaire (grille \u00e9tendue) est le plus riche en fonctionnalit\u00e9s : le conteneur est divis\u00e9 en cellules \u00e9gales mais un composant peut occuper plusieurs cellules de la grille et il est possible de faire une distribution dans des cellules distinctes. Un objet de la classe GridBagConstraints permet de donner les indications de positionnement et de dimension \u00e0 l'objet GridBagLayout. Les lignes et les colonnes prennent naissance au moment o\u00f9 les contr\u00f4les sont ajout\u00e9s. Chaque contr\u00f4le est associ\u00e9 \u00e0 un objet de la classe GridBagConstraints qui indique l'emplacement voulu pour le contr\u00f4le. 1 2 GridBagLayout gridBagLayout = new GridBagLayout (); GridBagConstraints gridBagConstraints = new GridBagConstraints (); L'objet GridBagConstraints peut \u00eatre manipul\u00e9 via les variables : Variable R\u00f4le gridx et gridy Ces variables contiennent les coordonn\u00e9es de l'origine de la grille. Elles permettent un positionnement pr\u00e9cis \u00e0 une certaine position d'un composant. Par d\u00e9faut elles ont la valeur GrigBagConstraint.RELATIVE qui indique qu'un composant se range \u00e0 droite du pr\u00e9c\u00e9dent. gridwidth, gridheight D\u00e9finissent combien de cellules va occuper le composant (en hauteur et largeur). Par d\u00e9faut la valeur est 1. L'indication est relative aux autres composants de la ligne ou de la colonne. La valeur GridBagConstraints.REMAINDER sp\u00e9cifie que le prochain composant ins\u00e9r\u00e9 sera le dernier de la ligne ou de la colonne courante. La valeur GridBagConstraints.RELATIVE place le composant apr\u00e8s le dernier composant d'une ligne ou d'une colonne. fill D\u00e9finit le sort d'un composant plus petit que la cellule de la grille. GridBagConstraints.NONE conserve la taille d'origine : valeur par d\u00e9faut GridBagConstraints.HORIZONTAL dilat\u00e9 horizontalement GridBagConstraints.VERTICAL dilat\u00e9 verticalement GridBagConstraints.BOTH dilat\u00e9s aux dimensions de la cellule. ipadx, ipady Permettent de d\u00e9finir l'agrandissement horizontal et vertical des composants. Ne fonctionne que si une dilatation est demand\u00e9e par fill. La valeur par d\u00e9faut est (0,0). anchor Lorsqu'un composant est plus petit que la cellule dans laquelle il est ins\u00e9r\u00e9, il peut \u00eatre positionn\u00e9 \u00e0 l'aide de cette variable pour d\u00e9finir le c\u00f4t\u00e9 par lequel le contr\u00f4le doit \u00eatre align\u00e9 dans la cellule. Les variables possibles sont NORTH, NORTHWEST, NORTHEAST, SOUTH, SOUTHWEST, SOUTHEAST, WEST et EAST. weightx, weighty Permettent de d\u00e9finir la r\u00e9partition de l'espace en cas de changement de dimension. GridBagLayout Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class CustomFrame extends Frame { public CustomFrame () { super (); this . setTitle ( \"Titre de la Fenetre \" ); this . setSize ( 300 , 150 ); Button b1 = new Button ( \" bouton 1 \" ); Button b2 = new Button ( \" bouton 2 \" ); Button b3 = new Button ( \" bouton 3 \" ); GridBagLayout gridBagLayout = new GridBagLayout (); GridBagConstraints gridBagConstraints = new GridBagConstraints (); this . setLayout ( gridBagLayout ); // Propri\u00e9t\u00e9s du GridBadConstraints gridBagConstraints . fill = GridBagConstraints . BOTH ; gridBagConstraints . weightx = 1 ; gridBagConstraints . weighty = 1 ; // Mise en forme des objets gridBagLayout . setConstraints ( b1 , gridBagConstraints ); gridBagLayout . setConstraints ( b2 , gridBagConstraints ); gridBagLayout . setConstraints ( b3 , gridBagConstraints ); this . add ( b1 ); this . add ( b2 ); this . add ( b3 ); pack (); show (); } public static void main ( String [] args ) { new CustomFrame (); } } R\u00e9sultat Cet exemple place trois boutons l'un \u00e0 cot\u00e9 de l'autre. Ceci permet en cas de changement de dimension du conteneur de conserver la mise en page : la taille des composants est automatiquement ajust\u00e9e. Pour placer les 3 boutons l'un au-dessus de l'autre, il faut affecter la valeur 1 \u00e0 la variable gbc.gridx :","title":"GridBagLayout"},{"location":"java/awt/whatisawt/","text":"Qu'est-ce que AWT ? Abstract Window Toolkit (AWT) est une biblioth\u00e8que graphique pour Java, faisant partie de Java Foundation Classes (JFC) . Cette biblioth\u00e8que a \u00e9t\u00e9 introduite d\u00e8s les premi\u00e8res versions de Java (depuis Java 2), la biblioth\u00e8que de gestion de fen\u00eatre officielle est Swing. Toutefois, AWT sert encore de fondement \u00e0 Swing, dans la mesure o\u00f9 de nombreuses classes Swing h\u00e9ritent de classes AWT. AWT permet notamment la cr\u00e9ation d'objets graphiques pr\u00e9con\u00e7us tel que des boutons, des sliders ou encore des menus d\u00e9roulants. Dimensionnement des composants En g\u00e9n\u00e9ral, le dimensionnement des composants est automatique gr\u00e2ce au LayoutManager . Pour donner \u00e0 un composant une taille donn\u00e9e, il faut red\u00e9finir la m\u00e9thopde getPreferedSize() de la classe Component . Dimensionnement des composants Code 1 2 3 4 5 6 public class CustomButton extends Button { @Override public Dimension getPreferredSize () { return new Dimension ( 800 , 250 ); } } Commentaire La m\u00e9thode getPreferedSize() indique la taille souhait\u00e9e mais pas celle impos\u00e9e. En fonction du LayoutManager, le composant pourra ou non imposer sa taille. Cette m\u00e9thode oblige \u00e0 sous-classer tous les composants. Une autre fa\u00e7on de faire est de se passer des Layout et de placer les composants \u00e0 la main en indiquant leurs coordonn\u00e9es et leurs dimensions. Pour supprimer le Layout par d\u00e9faut d'une classe, il faut appeler la m\u00e9thode setLayout() avec comme param\u00e8tre null. Trois m\u00e9thodes de la classe Component permettent de positionner des composants \u00e0 la position (x,y) par rapport au conteur dans lequel il est inclus et d'indiquer sa largeur et sa hauteur : setBounds(int x, int y, int largeur, int hauteur) , setLocation(int x , int y) et setSize(int largeur, int hauteur) . Posionnement des composants Lorqu'un composant graphique est int\u00e9gr\u00e9 dans un conteneur, son emplacement est determin\u00e9 de fa\u00e7on automatique : La mise en forme est dynamique. Cependant, un layout manager peut \u00eatre utilis\u00e9 pour d\u00e9finir la position de chaque \u00e9l\u00e9ment ins\u00e9r\u00e9. Dans ce cas, la position sp\u00e9cifi\u00e9e est relative aux autres composants. Chaque layout manager impl\u00e9mente l'interface java.awt.LayoutManager. Pour affecter un LayoutManager, il faut faire appel \u00e0 la m\u00e9thode setLayout() de la classe Container . Appel \u00e0 setLayout() Code 1 2 Panel panel = new Panel (); panel . setLayout ( new GridLayout ( 5 , 5 )); Pour cr\u00e9er un espace entre les composants et le bord de leur conteneur, il faut red\u00e9finir la m\u00e9thode getInsets() de la classe Container . Red\u00e9finition de getInsets() Code 1 2 3 4 5 6 7 @Override public Insets getInsets () { Insets normal = super . getInsets (); // Cet exemple permet de laisser 10 pixels en plus entre chaque bords du conteneur. return new Insets ( normal . top + 10 , normal . left + 10 , normal . bottom + 10 , normal . right + 10 ); }","title":"Qu'est-ce que AWT ?"},{"location":"java/awt/whatisawt/#quest-ce-que-awt","text":"Abstract Window Toolkit (AWT) est une biblioth\u00e8que graphique pour Java, faisant partie de Java Foundation Classes (JFC) . Cette biblioth\u00e8que a \u00e9t\u00e9 introduite d\u00e8s les premi\u00e8res versions de Java (depuis Java 2), la biblioth\u00e8que de gestion de fen\u00eatre officielle est Swing. Toutefois, AWT sert encore de fondement \u00e0 Swing, dans la mesure o\u00f9 de nombreuses classes Swing h\u00e9ritent de classes AWT. AWT permet notamment la cr\u00e9ation d'objets graphiques pr\u00e9con\u00e7us tel que des boutons, des sliders ou encore des menus d\u00e9roulants.","title":"Qu'est-ce que AWT ?"},{"location":"java/awt/whatisawt/#dimensionnement-des-composants","text":"En g\u00e9n\u00e9ral, le dimensionnement des composants est automatique gr\u00e2ce au LayoutManager . Pour donner \u00e0 un composant une taille donn\u00e9e, il faut red\u00e9finir la m\u00e9thopde getPreferedSize() de la classe Component . Dimensionnement des composants Code 1 2 3 4 5 6 public class CustomButton extends Button { @Override public Dimension getPreferredSize () { return new Dimension ( 800 , 250 ); } } Commentaire La m\u00e9thode getPreferedSize() indique la taille souhait\u00e9e mais pas celle impos\u00e9e. En fonction du LayoutManager, le composant pourra ou non imposer sa taille. Cette m\u00e9thode oblige \u00e0 sous-classer tous les composants. Une autre fa\u00e7on de faire est de se passer des Layout et de placer les composants \u00e0 la main en indiquant leurs coordonn\u00e9es et leurs dimensions. Pour supprimer le Layout par d\u00e9faut d'une classe, il faut appeler la m\u00e9thode setLayout() avec comme param\u00e8tre null. Trois m\u00e9thodes de la classe Component permettent de positionner des composants \u00e0 la position (x,y) par rapport au conteur dans lequel il est inclus et d'indiquer sa largeur et sa hauteur : setBounds(int x, int y, int largeur, int hauteur) , setLocation(int x , int y) et setSize(int largeur, int hauteur) .","title":"Dimensionnement des composants"},{"location":"java/awt/whatisawt/#posionnement-des-composants","text":"Lorqu'un composant graphique est int\u00e9gr\u00e9 dans un conteneur, son emplacement est determin\u00e9 de fa\u00e7on automatique : La mise en forme est dynamique. Cependant, un layout manager peut \u00eatre utilis\u00e9 pour d\u00e9finir la position de chaque \u00e9l\u00e9ment ins\u00e9r\u00e9. Dans ce cas, la position sp\u00e9cifi\u00e9e est relative aux autres composants. Chaque layout manager impl\u00e9mente l'interface java.awt.LayoutManager. Pour affecter un LayoutManager, il faut faire appel \u00e0 la m\u00e9thode setLayout() de la classe Container . Appel \u00e0 setLayout() Code 1 2 Panel panel = new Panel (); panel . setLayout ( new GridLayout ( 5 , 5 )); Pour cr\u00e9er un espace entre les composants et le bord de leur conteneur, il faut red\u00e9finir la m\u00e9thode getInsets() de la classe Container . Red\u00e9finition de getInsets() Code 1 2 3 4 5 6 7 @Override public Insets getInsets () { Insets normal = super . getInsets (); // Cet exemple permet de laisser 10 pixels en plus entre chaque bords du conteneur. return new Insets ( normal . top + 10 , normal . left + 10 , normal . bottom + 10 , normal . right + 10 ); }","title":"Posionnement des composants"},{"location":"java/global/history/","text":"Historique Version Java SE / JRE P\u00e9riode de maintenance Nouveaut\u00e9s majeures 1.0 Java 1.0 1996-2000 Version initiale 1.1 Java 1.1 1997-2000 JavaBeans, JDBC 1.2 J2SE 1.2 2000-2006 R\u00e9fl\u00e9xion, Swing 1.3 J2SE 1.3 2000-2001 HotSpot JVM, JPDA, JNDI inclus de base 1.4 J2SE 1.4 2000-2008 Mot cl\u00e9 assert, API Image, Java Web Start 1.5 J2SE 5.0 2002-2009 Int\u00e9gration de Java Web Start dans le JRE, Enumerations, imports statiques, refonte de la boucle for 1.6 Java SE 6 2005-2013 J2SE est remplac\u00e9 par Java SE et Sun supprime le .0 au num\u00e9ro de version 1.7 Java SE 7 2011-2015 Notation binaire, le multicatch 1.8 Java SE 8 2014-2018 Lambdas (+ refonte des collections et steams), les optionnels 9 Java SE 9 2018-? Projet Kulla (cr\u00e9ation d'un Shell pour Java) 10 Java SE 10 2018 (non LTS) Inf\u00e9rence des types des variables locales (mot cl\u00e9 var) 11 Java SE 11 ? Am\u00e9lioration des param\u00e8tres des lambdas, nouvel HTTP Client 12 Java SE 12 ? API Constants, am\u00e9lioration du garbage collector G1 13 Java SE 13 ? Nouvelle \u00e9criture possible des switch/case 14 Java SE 14 ? Incubator, plus de pr\u00e9cisions sur les NullPointerExceptions","title":"Historique"},{"location":"java/global/history/#historique","text":"Version Java SE / JRE P\u00e9riode de maintenance Nouveaut\u00e9s majeures 1.0 Java 1.0 1996-2000 Version initiale 1.1 Java 1.1 1997-2000 JavaBeans, JDBC 1.2 J2SE 1.2 2000-2006 R\u00e9fl\u00e9xion, Swing 1.3 J2SE 1.3 2000-2001 HotSpot JVM, JPDA, JNDI inclus de base 1.4 J2SE 1.4 2000-2008 Mot cl\u00e9 assert, API Image, Java Web Start 1.5 J2SE 5.0 2002-2009 Int\u00e9gration de Java Web Start dans le JRE, Enumerations, imports statiques, refonte de la boucle for 1.6 Java SE 6 2005-2013 J2SE est remplac\u00e9 par Java SE et Sun supprime le .0 au num\u00e9ro de version 1.7 Java SE 7 2011-2015 Notation binaire, le multicatch 1.8 Java SE 8 2014-2018 Lambdas (+ refonte des collections et steams), les optionnels 9 Java SE 9 2018-? Projet Kulla (cr\u00e9ation d'un Shell pour Java) 10 Java SE 10 2018 (non LTS) Inf\u00e9rence des types des variables locales (mot cl\u00e9 var) 11 Java SE 11 ? Am\u00e9lioration des param\u00e8tres des lambdas, nouvel HTTP Client 12 Java SE 12 ? API Constants, am\u00e9lioration du garbage collector G1 13 Java SE 13 ? Nouvelle \u00e9criture possible des switch/case 14 Java SE 14 ? Incubator, plus de pr\u00e9cisions sur les NullPointerExceptions","title":"Historique"},{"location":"java/global/interfaces/","text":"Interfaces ou classes abstraites ? Les interfaces Une interface permet de d\u00e9clarer des m\u00e9thodes, qui d\u00e9finit donc un ensemble de services visibles depuis l\u2019ext\u00e9rieur, sans se pr\u00e9occuper de la fa\u00e7on dont ces services seront r\u00e9ellement impl\u00e9ment\u00e9s. Une classe qui impl\u00e9mente une interface doit obligatoirement impl\u00e9menter chacune des m\u00e9thodes d\u00e9clar\u00e9es dans l\u2019interface, \u00e0 moins qu\u2019elle ne soit elle-m\u00eame d\u00e9clar\u00e9e abstraite. Les classes abstraites Une classe abstraite est une classe dont toutes les m\u00e9thodes n\u2019ont pas \u00e9t\u00e9 impl\u00e9ment\u00e9es. Elle n\u2019est donc pas instanciable, mais sert avant tout \u00e0 factoriser du code. Une classe qui h\u00e9rite d\u2019une classe abstraite doit obligatoirement impl\u00e9menter les m\u00e9thodes manquantes (qui ont \u00e9t\u00e9 elles-m\u00eames d\u00e9clar\u00e9es \u00ab abstraites \u00bb dans la classe parente). En revanche, elle n\u2019est pas oblig\u00e9e de r\u00e9impl\u00e9menter les m\u00e9thodes d\u00e9j\u00e0 impl\u00e9ment\u00e9es dans la classe parente (d\u2019o\u00f9 une maintenance du code plus facile).","title":"Interfaces ou classes abstraites"},{"location":"java/global/interfaces/#interfaces-ou-classes-abstraites","text":"","title":"Interfaces ou classes abstraites ?"},{"location":"java/global/interfaces/#les-interfaces","text":"Une interface permet de d\u00e9clarer des m\u00e9thodes, qui d\u00e9finit donc un ensemble de services visibles depuis l\u2019ext\u00e9rieur, sans se pr\u00e9occuper de la fa\u00e7on dont ces services seront r\u00e9ellement impl\u00e9ment\u00e9s. Une classe qui impl\u00e9mente une interface doit obligatoirement impl\u00e9menter chacune des m\u00e9thodes d\u00e9clar\u00e9es dans l\u2019interface, \u00e0 moins qu\u2019elle ne soit elle-m\u00eame d\u00e9clar\u00e9e abstraite.","title":"Les interfaces"},{"location":"java/global/interfaces/#les-classes-abstraites","text":"Une classe abstraite est une classe dont toutes les m\u00e9thodes n\u2019ont pas \u00e9t\u00e9 impl\u00e9ment\u00e9es. Elle n\u2019est donc pas instanciable, mais sert avant tout \u00e0 factoriser du code. Une classe qui h\u00e9rite d\u2019une classe abstraite doit obligatoirement impl\u00e9menter les m\u00e9thodes manquantes (qui ont \u00e9t\u00e9 elles-m\u00eames d\u00e9clar\u00e9es \u00ab abstraites \u00bb dans la classe parente). En revanche, elle n\u2019est pas oblig\u00e9e de r\u00e9impl\u00e9menter les m\u00e9thodes d\u00e9j\u00e0 impl\u00e9ment\u00e9es dans la classe parente (d\u2019o\u00f9 une maintenance du code plus facile).","title":"Les classes abstraites"},{"location":"java/global/ref/","text":"Les r\u00e9f\u00e9rences Exemple de classe pour la suite User.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class User { private int age ; private int id ; public User () { super (); // age & id = 0 by default } public User ( int age , int id ) { super (); this . age = age ; this . id = id ; } // getters and setters } Supposons maintenant ces extraits de code : Exemple 1 Code 1 User user ; Commentaire Aucune instance de la classe User est cr\u00e9\u00e9e ici, et l'espace m\u00e9moire n\u00e9cessaire \u00e0 stocker un User n'est pas res\u00e9rv\u00e9. En r\u00e9alit\u00e9, la variable user est une r\u00e9f\u00e9rence. Ce code va donc allouer la m\u00e9moire n\u00e9cessaire pour stocker une r\u00e9f\u00e9rence. Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire (Le losange indique un nom de variable, le rectangle violet d\u00e9signe une case m\u00e9moire): flowchart LR ?:::ppl <--> User{user} classDef ppl fill:purple; Exemple 2 Code 1 new User (); Commentaire Cette fois, un espace m\u00e9moire est allou\u00e9 permettant de stocker un objet User. On a donc quelque chose qui ressemble \u00e0 \u00e7a : flowchart LR OBJ(age=0\\n id=0):::grn classDef grn fill:green; Exemple 3 Code 1 User user = new User (); Commentaire Ici, on d\u00e9clare d'abord la r\u00e9f\u00e9rence avec User user puis on cr\u00e9\u00e9 ensuite l'objet gr\u00e2ce \u00e0 l'op\u00e9rateur new User() . Vient ensuite l' affectation gr\u00e2ce au = : La r\u00e9f\u00e9rence stock\u00e9e dans l'espace m\u00e9moire reserv\u00e9 lors de la d\u00e9claration de user prend la valeur de l'address m\u00e9moire de l'objet cr\u00e9\u00e9. Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire: flowchart LR MEM[ ]:::ppl <--> User{user} OBJ(age=0\\n id=0):::grn --- MEM classDef ppl fill:purple; classDef grn fill:green; Exemple 4 Code 1 2 User user1 = new User ( 20 , 1000 ); User user2 = user1 ; Commentaire Ici, on cr\u00e9\u00e9 une instance de User avec User user1 = new User(20,1000) , r\u00e9f\u00e9renc\u00e9 par la variable user1 . Comme vu pr\u00e9c\u00e9demment, l'instruction User user2 va d\u00e9clarer une variable user2 : Aucun utilisateur n'est cr\u00e9\u00e9, on reserve juste un espace m\u00e9moire pour une r\u00e9f\u00e9rence. Lors de user2 = user1 , la valeur de la r\u00e9f\u00e9rence de user1 est recopi\u00e9e dans l'espace m\u00e9moire correspondant \u00e0 user2 : user2 r\u00e9f\u00e9rence donc l'objet qui \u00e9tait r\u00e9f\u00e9renc\u00e9 par user1 . Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire: flowchart LR MEM1[ ]:::ppl <--> User{user1} MEM2[ ]:::ppl <--> User2{user2} OBJ(age=20\\n id=1000):::grn --- MEM1 OBJ:::grn --- MEM2 classDef ppl fill:purple; classDef grn fill:green; Exemple 5 Code 1 2 3 User user1 = new User ( 20 , 1000 ); User user2 = new User (); user2 = user1 ; Commentaire Ici, aux lignes 1 et 2, on cr\u00e9\u00e9 deux objets r\u00e9f\u00e9renc\u00e9s par les variables user1 et user2 . A la ligne 3, on recopie l\u2019adresse de l\u2019objet r\u00e9f\u00e9rtenc\u00e9 par user1 dans l\u2019espace m\u00e9moire alou\u00e9 \u00e0 user2 , ce qui revient \u00e0 dire que user2 r\u00e9f\u00e9rence maintenant le m\u00eame objet que user1 : Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire: flowchart LR MEM1[ ]:::ppl <--> User{user1} MEM2[ ]:::ppl <--> User2{user2} OBJ1(age=20\\n id=1000):::grn --- MEM1 OBJ2(age=0\\n id=0):::grn OBJ1:::grn --- MEM2 classDef ppl fill:purple; classDef grn fill:green; Plus aucune variable ne d\u00e9signe le second objet en m\u00e9moire. Il occupe donc une place inutile en m\u00e9moire. Il sera d\u00e9truit par le garbage collector dont le but est justement de supprimer en m\u00e9moire les objets qui ne sont plus r\u00e9f\u00e9renc\u00e9s.","title":"Les r\u00e9f\u00e9rences"},{"location":"java/global/ref/#les-references","text":"","title":"Les r\u00e9f\u00e9rences"},{"location":"java/global/ref/#exemple-de-classe-pour-la-suite","text":"User.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class User { private int age ; private int id ; public User () { super (); // age & id = 0 by default } public User ( int age , int id ) { super (); this . age = age ; this . id = id ; } // getters and setters } Supposons maintenant ces extraits de code : Exemple 1 Code 1 User user ; Commentaire Aucune instance de la classe User est cr\u00e9\u00e9e ici, et l'espace m\u00e9moire n\u00e9cessaire \u00e0 stocker un User n'est pas res\u00e9rv\u00e9. En r\u00e9alit\u00e9, la variable user est une r\u00e9f\u00e9rence. Ce code va donc allouer la m\u00e9moire n\u00e9cessaire pour stocker une r\u00e9f\u00e9rence. Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire (Le losange indique un nom de variable, le rectangle violet d\u00e9signe une case m\u00e9moire): flowchart LR ?:::ppl <--> User{user} classDef ppl fill:purple; Exemple 2 Code 1 new User (); Commentaire Cette fois, un espace m\u00e9moire est allou\u00e9 permettant de stocker un objet User. On a donc quelque chose qui ressemble \u00e0 \u00e7a : flowchart LR OBJ(age=0\\n id=0):::grn classDef grn fill:green; Exemple 3 Code 1 User user = new User (); Commentaire Ici, on d\u00e9clare d'abord la r\u00e9f\u00e9rence avec User user puis on cr\u00e9\u00e9 ensuite l'objet gr\u00e2ce \u00e0 l'op\u00e9rateur new User() . Vient ensuite l' affectation gr\u00e2ce au = : La r\u00e9f\u00e9rence stock\u00e9e dans l'espace m\u00e9moire reserv\u00e9 lors de la d\u00e9claration de user prend la valeur de l'address m\u00e9moire de l'objet cr\u00e9\u00e9. Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire: flowchart LR MEM[ ]:::ppl <--> User{user} OBJ(age=0\\n id=0):::grn --- MEM classDef ppl fill:purple; classDef grn fill:green; Exemple 4 Code 1 2 User user1 = new User ( 20 , 1000 ); User user2 = user1 ; Commentaire Ici, on cr\u00e9\u00e9 une instance de User avec User user1 = new User(20,1000) , r\u00e9f\u00e9renc\u00e9 par la variable user1 . Comme vu pr\u00e9c\u00e9demment, l'instruction User user2 va d\u00e9clarer une variable user2 : Aucun utilisateur n'est cr\u00e9\u00e9, on reserve juste un espace m\u00e9moire pour une r\u00e9f\u00e9rence. Lors de user2 = user1 , la valeur de la r\u00e9f\u00e9rence de user1 est recopi\u00e9e dans l'espace m\u00e9moire correspondant \u00e0 user2 : user2 r\u00e9f\u00e9rence donc l'objet qui \u00e9tait r\u00e9f\u00e9renc\u00e9 par user1 . Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire: flowchart LR MEM1[ ]:::ppl <--> User{user1} MEM2[ ]:::ppl <--> User2{user2} OBJ(age=20\\n id=1000):::grn --- MEM1 OBJ:::grn --- MEM2 classDef ppl fill:purple; classDef grn fill:green; Exemple 5 Code 1 2 3 User user1 = new User ( 20 , 1000 ); User user2 = new User (); user2 = user1 ; Commentaire Ici, aux lignes 1 et 2, on cr\u00e9\u00e9 deux objets r\u00e9f\u00e9renc\u00e9s par les variables user1 et user2 . A la ligne 3, on recopie l\u2019adresse de l\u2019objet r\u00e9f\u00e9rtenc\u00e9 par user1 dans l\u2019espace m\u00e9moire alou\u00e9 \u00e0 user2 , ce qui revient \u00e0 dire que user2 r\u00e9f\u00e9rence maintenant le m\u00eame objet que user1 : Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire: flowchart LR MEM1[ ]:::ppl <--> User{user1} MEM2[ ]:::ppl <--> User2{user2} OBJ1(age=20\\n id=1000):::grn --- MEM1 OBJ2(age=0\\n id=0):::grn OBJ1:::grn --- MEM2 classDef ppl fill:purple; classDef grn fill:green; Plus aucune variable ne d\u00e9signe le second objet en m\u00e9moire. Il occupe donc une place inutile en m\u00e9moire. Il sera d\u00e9truit par le garbage collector dont le but est justement de supprimer en m\u00e9moire les objets qui ne sont plus r\u00e9f\u00e9renc\u00e9s.","title":"Exemple de classe pour la suite"},{"location":"java/global/vars/","text":"Les variables et fonctions Les types primitifs Type primitif Taille en m\u00e9moire (en bits) Intervalle Valeur par d\u00e9faut char 16 \\([Unicode~{0} ; Unicode~2^{16} - 1]\\) '\\u0000' byte 8 \\([-127 ; 127]\\) \\(0\\) short 16 \\([-2^{15} ; 2^{15} - 1]\\) \\(0\\) int 32 \\([-2^{31} ; 2^{31} -1]\\) \\(0\\) long 64 \\([-2^{63} ; 2^{63} - 1]\\) \\(0L\\) float 32 \\(32~bits~IEEE~754~floating~point~numbers\\) \\(0.0f\\) double 64 \\(64~bits~IEEE~754~floating~point~numbers\\) \\(0.0d\\) boolean 1 \\(\\{true;false\\}\\) \\(false\\) Les valeurs par d\u00e9faut ne s'appliquent qu'aux attributs d'une classe , pas aux variables locales. D\u00e9claration des types primitifs Exemple Code 1 int i ; Commentaire A l'\u00e9xecution, un espace m\u00e9moire de 32 bits est reserv\u00e9 par la JVM permettant de stocker un entier. Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire (Le losange indique un nom de variable, le rectangle violet d\u00e9signe une case m\u00e9moire) : flowchart LR ?:::ppl <--> I{i} classDef ppl fill:purple; Affectation des types primitifs L'affectation des types primitifs fonctionne par valeur . Exemple Code 1 2 3 4 5 int i = 1 ; int j = i ; i = 2 ; System . out . println ( i ); // Affiche '2' System . out . println ( j ); // Affiche '1' Commentaire Apr\u00e8s l'ex\u00e9cution de ce code, il n'y a plus aucun lien entre i et j . Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire : flowchart LR 2:::ppl <--> I{i} 1:::ppl <--> J{j} classDef ppl fill:purple; Attention En Java, les tableaux sont des objets, que ce soit des tableaux de type primitifs ou d'objets. Ainsi, le code suivant : 1 int arr [] = { 1 , 2 , 3 }; Est simplement un raccourci pour : 1 2 3 4 int arr [] = new int [ 3 ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; On reviendra donc sur les tableaux dans la partie d\u00e9di\u00e9e aux objets.","title":"Les types primitifs"},{"location":"java/global/vars/#les-variables-et-fonctions","text":"","title":"Les variables et fonctions"},{"location":"java/global/vars/#les-types-primitifs","text":"Type primitif Taille en m\u00e9moire (en bits) Intervalle Valeur par d\u00e9faut char 16 \\([Unicode~{0} ; Unicode~2^{16} - 1]\\) '\\u0000' byte 8 \\([-127 ; 127]\\) \\(0\\) short 16 \\([-2^{15} ; 2^{15} - 1]\\) \\(0\\) int 32 \\([-2^{31} ; 2^{31} -1]\\) \\(0\\) long 64 \\([-2^{63} ; 2^{63} - 1]\\) \\(0L\\) float 32 \\(32~bits~IEEE~754~floating~point~numbers\\) \\(0.0f\\) double 64 \\(64~bits~IEEE~754~floating~point~numbers\\) \\(0.0d\\) boolean 1 \\(\\{true;false\\}\\) \\(false\\) Les valeurs par d\u00e9faut ne s'appliquent qu'aux attributs d'une classe , pas aux variables locales.","title":"Les types primitifs"},{"location":"java/global/vars/#declaration-des-types-primitifs","text":"Exemple Code 1 int i ; Commentaire A l'\u00e9xecution, un espace m\u00e9moire de 32 bits est reserv\u00e9 par la JVM permettant de stocker un entier. Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire (Le losange indique un nom de variable, le rectangle violet d\u00e9signe une case m\u00e9moire) : flowchart LR ?:::ppl <--> I{i} classDef ppl fill:purple;","title":"D\u00e9claration des types primitifs"},{"location":"java/global/vars/#affectation-des-types-primitifs","text":"L'affectation des types primitifs fonctionne par valeur . Exemple Code 1 2 3 4 5 int i = 1 ; int j = i ; i = 2 ; System . out . println ( i ); // Affiche '2' System . out . println ( j ); // Affiche '1' Commentaire Apr\u00e8s l'ex\u00e9cution de ce code, il n'y a plus aucun lien entre i et j . Cela peut \u00eatre repr\u00e9sent\u00e9 par le sch\u00e9ma suivant en m\u00e9moire : flowchart LR 2:::ppl <--> I{i} 1:::ppl <--> J{j} classDef ppl fill:purple; Attention En Java, les tableaux sont des objets, que ce soit des tableaux de type primitifs ou d'objets. Ainsi, le code suivant : 1 int arr [] = { 1 , 2 , 3 }; Est simplement un raccourci pour : 1 2 3 4 int arr [] = new int [ 3 ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; On reviendra donc sur les tableaux dans la partie d\u00e9di\u00e9e aux objets.","title":"Affectation des types primitifs"},{"location":"java/global/whatisjava/","text":"Qu'est-ce que Java ? Java est un langage de programmation, initialement d\u00e9velopp\u00e9 par Sun Microsystems puis acquis par Oracle \u00e0 la suite du rachat de l'entreprise en 2009. Plus d'information sur le site d'Oracle . La technologie Java regroupe : Des standards (la plate-forme Java) d\u00e9finis sous forme de sp\u00e9cification par le JCP (Java Community Process) : Java SE (Java Standard Edition) : Contient toutes les biblioth\u00e9ques et API Java de base tel que java.lang , java.io , java.net , java.util ... Java EE (Java Entreprise Edition) : En plus des biblioth\u00e8ques de base, ajoute des biblioth\u00e8ques pour d\u00e9ployer du Java multi-niveaux, bas\u00e9 sur des composants fonctionnant sur un serveur d'application. Java EE est donc utile pour d\u00e9ployer des applications web d'entreprise. Java ME (Java Micro Edition) : Est utilis\u00e9 dans le d\u00e9veloppement d'applications mobiles et dans les syst\u00e8mes embarqu\u00e9s. Des logiciels dont des impl\u00e9mentations de ces sp\u00e9cifications Des communaut\u00e9s d'entreprises, organisations \u00e0 but non lucratif, pouvant poss\u00e9der des parties des marques, brevets et parts de march\u00e9 li\u00e9s \u00e0 la technologie Java. Notions de JDK, JVE et JVM Le JDK Le JDK (Java Development Kit) est un environnement de d\u00e9veloppement logiciel utilis\u00e9 pour d\u00e9velopper des applications et des applets Java. Il comprend le JRE (Java Runtime Environment) , un interpr\u00e9teur Java, un compilateur (javac), un archiveur (jar), un g\u00e9n\u00e9rateur de documentation (javadoc) et d'autres outils n\u00e9cessaires au d\u00e9veloppement Java. Le JRE Le JRE (Java Runtime Environment) fournit des exigences minimales pour l'ex\u00e9cution d'une application Java. Il comprend la JVM (Java Virtual Machine) , des classes principales et des fichiers de soutien. La JVM La JVM (Java Virtual Machine) agit comme un moteur d'\u00e9xecution pour ex\u00e9cuter les applications Java. C'est elle qui appelle la m\u00e9thode principale pr\u00e9sente dans un code Java. Les applications Java sont appel\u00e9es WORA (Write Once Run Anywhere). Cela signifie qu'un programmeur peut d\u00e9velopper un code Java sur un syst\u00e8me et s'attendre \u00e0 ce qu'il fonctionne sur n'importe quel autre syst\u00e8me compatible Java sans aucun ajustement. Tout ceci est possible gr\u00e2ce \u00e0 la JVM. Pour mieux comprendre, il faut s'attarder sur la compilation en Java. Compilation Java Lorsqu'on d\u00e9veloppe en Java, le code est \u00e9crit dans des fichiers source .java . Lorsqu'un fichier .java est compil\u00e9 gr\u00e2ce \u00e0 javac par exemple, un fichier .class contenant du code d'octets (aussi appel\u00e9 bytecode) est cr\u00e9\u00e9. Afin que le bytecode soit reconue par l'OS, celui-ci passe par diff\u00e9rentes \u00e9tapes lorsque nous l'ex\u00e9cutons. Ces \u00e9tapes sont assur\u00e9es par la JVM. Le sch\u00e9ma ci-dessous r\u00e9sume les \u00e9tapes de compilation/interpr\u00e9tation du code Java : Installation Pour compiler et ex\u00e9cuter du code Java, il faut donc un JDK, un JRE et une JVM. Chaque fois que le d\u00e9veloppeur t\u00e9l\u00e9charge un JDK, celui-ci inclut un JRE compatible avec la version, et ce JRE comprend lui-m\u00eame un JVM par d\u00e9faut. Il faut savoir qu'il est cependant possible de t\u00e9l\u00e9charger le JRE ind\u00e9pendamment du JDK et de choisir la JVM parmi les diff\u00e9rents types disponibles . Quel JDK choisir ? Un sondage sur 10500 d\u00e9veloppeurs Java a \u00e9t\u00e9 r\u00e9alis\u00e9 en 2018, dans lequel une question porte sur le JDK qu'ils utilisent. Voici le r\u00e9sultat de ce sondage : Les JDK les plus utilis\u00e9s sont donc Oracle JDK et OpenJDK . OpenJDK OpenJDK est une impl\u00e9mentation gratuite et open-source de la plate-forme Java SE Edition. Il a \u00e9t\u00e9 initialement publi\u00e9 en 2007 comme le r\u00e9sultat du d\u00e9veloppement que Sun Microsystems a commenc\u00e9 en 2006. Il convient de souligner que l'OpenJDK est une impl\u00e9mentation de r\u00e9f\u00e9rence officielle de Java Standard Edition depuis la version SE 7. Oracle JDK La soci\u00e9t\u00e9 Oracle fournit un JDK nomm\u00e9 Oracle JDK . Comme la grande majorit\u00e9 des JDK, celui-ci est bas\u00e9 sur OpenJDK. Les diff\u00e9rences majeurs entre les deux JDK cit\u00e9s ci-dessus proviennent de leur performance et licences. Un article de 2020 par Baeldung explique ces diff\u00e9rences .","title":"Qu'est-ce que Java ?"},{"location":"java/global/whatisjava/#quest-ce-que-java","text":"Java est un langage de programmation, initialement d\u00e9velopp\u00e9 par Sun Microsystems puis acquis par Oracle \u00e0 la suite du rachat de l'entreprise en 2009. Plus d'information sur le site d'Oracle . La technologie Java regroupe : Des standards (la plate-forme Java) d\u00e9finis sous forme de sp\u00e9cification par le JCP (Java Community Process) : Java SE (Java Standard Edition) : Contient toutes les biblioth\u00e9ques et API Java de base tel que java.lang , java.io , java.net , java.util ... Java EE (Java Entreprise Edition) : En plus des biblioth\u00e8ques de base, ajoute des biblioth\u00e8ques pour d\u00e9ployer du Java multi-niveaux, bas\u00e9 sur des composants fonctionnant sur un serveur d'application. Java EE est donc utile pour d\u00e9ployer des applications web d'entreprise. Java ME (Java Micro Edition) : Est utilis\u00e9 dans le d\u00e9veloppement d'applications mobiles et dans les syst\u00e8mes embarqu\u00e9s. Des logiciels dont des impl\u00e9mentations de ces sp\u00e9cifications Des communaut\u00e9s d'entreprises, organisations \u00e0 but non lucratif, pouvant poss\u00e9der des parties des marques, brevets et parts de march\u00e9 li\u00e9s \u00e0 la technologie Java.","title":"Qu'est-ce que Java ?"},{"location":"java/global/whatisjava/#notions-de-jdk-jve-et-jvm","text":"","title":"Notions de JDK, JVE et JVM"},{"location":"java/global/whatisjava/#le-jdk","text":"Le JDK (Java Development Kit) est un environnement de d\u00e9veloppement logiciel utilis\u00e9 pour d\u00e9velopper des applications et des applets Java. Il comprend le JRE (Java Runtime Environment) , un interpr\u00e9teur Java, un compilateur (javac), un archiveur (jar), un g\u00e9n\u00e9rateur de documentation (javadoc) et d'autres outils n\u00e9cessaires au d\u00e9veloppement Java.","title":"Le JDK"},{"location":"java/global/whatisjava/#le-jre","text":"Le JRE (Java Runtime Environment) fournit des exigences minimales pour l'ex\u00e9cution d'une application Java. Il comprend la JVM (Java Virtual Machine) , des classes principales et des fichiers de soutien.","title":"Le JRE"},{"location":"java/global/whatisjava/#la-jvm","text":"La JVM (Java Virtual Machine) agit comme un moteur d'\u00e9xecution pour ex\u00e9cuter les applications Java. C'est elle qui appelle la m\u00e9thode principale pr\u00e9sente dans un code Java. Les applications Java sont appel\u00e9es WORA (Write Once Run Anywhere). Cela signifie qu'un programmeur peut d\u00e9velopper un code Java sur un syst\u00e8me et s'attendre \u00e0 ce qu'il fonctionne sur n'importe quel autre syst\u00e8me compatible Java sans aucun ajustement. Tout ceci est possible gr\u00e2ce \u00e0 la JVM. Pour mieux comprendre, il faut s'attarder sur la compilation en Java.","title":"La JVM"},{"location":"java/global/whatisjava/#compilation-java","text":"Lorsqu'on d\u00e9veloppe en Java, le code est \u00e9crit dans des fichiers source .java . Lorsqu'un fichier .java est compil\u00e9 gr\u00e2ce \u00e0 javac par exemple, un fichier .class contenant du code d'octets (aussi appel\u00e9 bytecode) est cr\u00e9\u00e9. Afin que le bytecode soit reconue par l'OS, celui-ci passe par diff\u00e9rentes \u00e9tapes lorsque nous l'ex\u00e9cutons. Ces \u00e9tapes sont assur\u00e9es par la JVM. Le sch\u00e9ma ci-dessous r\u00e9sume les \u00e9tapes de compilation/interpr\u00e9tation du code Java :","title":"Compilation Java"},{"location":"java/global/whatisjava/#installation","text":"Pour compiler et ex\u00e9cuter du code Java, il faut donc un JDK, un JRE et une JVM. Chaque fois que le d\u00e9veloppeur t\u00e9l\u00e9charge un JDK, celui-ci inclut un JRE compatible avec la version, et ce JRE comprend lui-m\u00eame un JVM par d\u00e9faut. Il faut savoir qu'il est cependant possible de t\u00e9l\u00e9charger le JRE ind\u00e9pendamment du JDK et de choisir la JVM parmi les diff\u00e9rents types disponibles . Quel JDK choisir ? Un sondage sur 10500 d\u00e9veloppeurs Java a \u00e9t\u00e9 r\u00e9alis\u00e9 en 2018, dans lequel une question porte sur le JDK qu'ils utilisent. Voici le r\u00e9sultat de ce sondage : Les JDK les plus utilis\u00e9s sont donc Oracle JDK et OpenJDK . OpenJDK OpenJDK est une impl\u00e9mentation gratuite et open-source de la plate-forme Java SE Edition. Il a \u00e9t\u00e9 initialement publi\u00e9 en 2007 comme le r\u00e9sultat du d\u00e9veloppement que Sun Microsystems a commenc\u00e9 en 2006. Il convient de souligner que l'OpenJDK est une impl\u00e9mentation de r\u00e9f\u00e9rence officielle de Java Standard Edition depuis la version SE 7. Oracle JDK La soci\u00e9t\u00e9 Oracle fournit un JDK nomm\u00e9 Oracle JDK . Comme la grande majorit\u00e9 des JDK, celui-ci est bas\u00e9 sur OpenJDK. Les diff\u00e9rences majeurs entre les deux JDK cit\u00e9s ci-dessus proviennent de leur performance et licences. Un article de 2020 par Baeldung explique ces diff\u00e9rences .","title":"Installation"},{"location":"java/global/advanced/garbageCollector/","text":"Garbage Collector Le Garbage Collector est impl\u00e9ment\u00e9 depuis l'apparition de la JVM. Son r\u00f4le consiste, en grande partie, \u00e0 g\u00e9rer la m\u00e9moire \u00e0 notre place.","title":"Garbage Collector"},{"location":"java/global/advanced/garbageCollector/#garbage-collector","text":"Le Garbage Collector est impl\u00e9ment\u00e9 depuis l'apparition de la JVM. Son r\u00f4le consiste, en grande partie, \u00e0 g\u00e9rer la m\u00e9moire \u00e0 notre place.","title":"Garbage Collector"},{"location":"java/global/advanced/lambdas/","text":"Les lambdas Plusieurs exemples d'utilisation des lambdas : Quelques exemples d'utilisation Pour parcourir des listes Exemple Before Lambdas 1 2 3 for ( Something s : list ) { System . out . println ( s . doSomething ()); } After Lambdas 1 2 3 list . forEach ( Something :: doSomething ); // or list . forEach ( element -> element . doSomething ()); Commentaire La m\u00e9thode forEach() dans l'interface Iterable attend en param\u00e8tre une interface fonctionnelle de type Consumer Pour les listeners Exemple Before Lambdas 1 2 3 4 5 button . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent event ) { doSomething ( event ); } }); After Lambdas 1 button . addActionListener ( event -> doSomething ( event )); Commentaire L'expression lambda permet de d\u00e9finir une impl\u00e9mentation d'une interface fonctionnelle. Le type du param\u00e8tre n'est pas obligatoire : le compilateur va tenter de r\u00e9aliser une inf\u00e9rence du type pour le d\u00e9terminer selon le contexte. Pour les threads Exemple Before Lambdas 1 2 3 4 5 6 7 Thread thread = new Thread ( new Runnable () { @Override public void run () { doSomething (); } }); thread . start (); After Lambdas 1 2 Thread thread = new Thread (() -> { doSomething (); }); thread . start (); Commentaire L'utilisation d'une expression lambda \u00e9vite d'avoir \u00e0 \u00e9crire le code n\u00e9cessaire \u00e0 la d\u00e9claration de la classe anonyme de type Runnable et de la m\u00e9thode. Les interfaces fonctionnelles Une interfacce fonctionnelle est une interface : Qui doit n'avoir qu'une seule m\u00e9thode d\u00e9clar\u00e9e abstraite (les m\u00e9thodes d\u00e9finies dans la classe Object ne sont pas prises en compte comme \u00e9tant des m\u00e9thodes abstraites) Dont toutes les m\u00e9thodes doivent \u00eatre public Qui peut avoir des m\u00e9thodes par d\u00e9faut et static Certaines interfaces (avant Java 8) resp\u00e8ctent ses r\u00e8gles et sont donc des interfaces fonctionnelles, comme Comparator<T> , Callable<T> , Runnable , ActionListener ... On peut donc utiliser une expression lambda au lieu d'une classe anonyme. Quelques exemples 1 2 3 4 5 6 7 8 9 // Le type du param\u00e8tre peut \u00eatre pr\u00e9cis\u00e9 entre parenth\u00e8ses Consumer < String > display = ( String message ) -> System . out . println ( message ); // Il est possible d'annoter les param\u00e8tres des expressions lambdas si le type est pr\u00e9cis\u00e9 Comparator < String > comparator = ( @NotNull String chaine1 , @NotNull String chaine2 ) -> Integer . compare ( chaine1 . length (), chaine2 . length ()); // Si aucun param\u00e8tre n'est n\u00e9cessaire, on utilise des parenth\u00e8ses vides Runnable process = () -> System . out . println ( \"processing\" ); Function < Integer , Boolean > isEven = number -> { return ( number % 2 == 0 ); }; BiFunction < Integer , Integer , Long > add = ( x , y ) -> ( long ) x + y ; IntFunction intFunction = x -> x * 2 ; Voici un exemple de d\u00e9finition d'une inteface fonctionnelle : Quelques exemples Operation.java 1 2 3 4 @FunctionalInterface public interface Operation { int calcul ( int a , int b ); } Main.java 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main ( String [] args ) { System . out . println ( execute ( 20 , 10 , ( a , b ) -> a + b )); // 30 System . out . println ( execute ( 20 , 10 , ( a , b ) -> a - b )); // 10 } private static int execute ( int a , int b , Operation operation ) { return operation . calcul ( a , b ); } }","title":"Les lambdas"},{"location":"java/global/advanced/lambdas/#les-lambdas","text":"Plusieurs exemples d'utilisation des lambdas :","title":"Les lambdas"},{"location":"java/global/advanced/lambdas/#quelques-exemples-dutilisation","text":"","title":"Quelques exemples d'utilisation"},{"location":"java/global/advanced/lambdas/#pour-parcourir-des-listes","text":"Exemple Before Lambdas 1 2 3 for ( Something s : list ) { System . out . println ( s . doSomething ()); } After Lambdas 1 2 3 list . forEach ( Something :: doSomething ); // or list . forEach ( element -> element . doSomething ()); Commentaire La m\u00e9thode forEach() dans l'interface Iterable attend en param\u00e8tre une interface fonctionnelle de type Consumer","title":"Pour parcourir des listes"},{"location":"java/global/advanced/lambdas/#pour-les-listeners","text":"Exemple Before Lambdas 1 2 3 4 5 button . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent event ) { doSomething ( event ); } }); After Lambdas 1 button . addActionListener ( event -> doSomething ( event )); Commentaire L'expression lambda permet de d\u00e9finir une impl\u00e9mentation d'une interface fonctionnelle. Le type du param\u00e8tre n'est pas obligatoire : le compilateur va tenter de r\u00e9aliser une inf\u00e9rence du type pour le d\u00e9terminer selon le contexte.","title":"Pour les listeners"},{"location":"java/global/advanced/lambdas/#pour-les-threads","text":"Exemple Before Lambdas 1 2 3 4 5 6 7 Thread thread = new Thread ( new Runnable () { @Override public void run () { doSomething (); } }); thread . start (); After Lambdas 1 2 Thread thread = new Thread (() -> { doSomething (); }); thread . start (); Commentaire L'utilisation d'une expression lambda \u00e9vite d'avoir \u00e0 \u00e9crire le code n\u00e9cessaire \u00e0 la d\u00e9claration de la classe anonyme de type Runnable et de la m\u00e9thode.","title":"Pour les threads"},{"location":"java/global/advanced/lambdas/#les-interfaces-fonctionnelles","text":"Une interfacce fonctionnelle est une interface : Qui doit n'avoir qu'une seule m\u00e9thode d\u00e9clar\u00e9e abstraite (les m\u00e9thodes d\u00e9finies dans la classe Object ne sont pas prises en compte comme \u00e9tant des m\u00e9thodes abstraites) Dont toutes les m\u00e9thodes doivent \u00eatre public Qui peut avoir des m\u00e9thodes par d\u00e9faut et static Certaines interfaces (avant Java 8) resp\u00e8ctent ses r\u00e8gles et sont donc des interfaces fonctionnelles, comme Comparator<T> , Callable<T> , Runnable , ActionListener ... On peut donc utiliser une expression lambda au lieu d'une classe anonyme. Quelques exemples 1 2 3 4 5 6 7 8 9 // Le type du param\u00e8tre peut \u00eatre pr\u00e9cis\u00e9 entre parenth\u00e8ses Consumer < String > display = ( String message ) -> System . out . println ( message ); // Il est possible d'annoter les param\u00e8tres des expressions lambdas si le type est pr\u00e9cis\u00e9 Comparator < String > comparator = ( @NotNull String chaine1 , @NotNull String chaine2 ) -> Integer . compare ( chaine1 . length (), chaine2 . length ()); // Si aucun param\u00e8tre n'est n\u00e9cessaire, on utilise des parenth\u00e8ses vides Runnable process = () -> System . out . println ( \"processing\" ); Function < Integer , Boolean > isEven = number -> { return ( number % 2 == 0 ); }; BiFunction < Integer , Integer , Long > add = ( x , y ) -> ( long ) x + y ; IntFunction intFunction = x -> x * 2 ; Voici un exemple de d\u00e9finition d'une inteface fonctionnelle : Quelques exemples Operation.java 1 2 3 4 @FunctionalInterface public interface Operation { int calcul ( int a , int b ); } Main.java 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main ( String [] args ) { System . out . println ( execute ( 20 , 10 , ( a , b ) -> a + b )); // 30 System . out . println ( execute ( 20 , 10 , ( a , b ) -> a - b )); // 10 } private static int execute ( int a , int b , Operation operation ) { return operation . calcul ( a , b ); } }","title":"Les interfaces fonctionnelles"},{"location":"java/swing/whatisswing/","text":"Qu'est-ce que Swing ? Abstract Window Toolkit (AWT) est une biblioth\u00e8que graphique pour Java, faisant partie de Java Foundation Classes (JFC) . Cette biblioth\u00e8que a \u00e9t\u00e9 introduite d\u00e8s les premi\u00e8res versions de Java (depuis Java 2), la biblioth\u00e8que de gestion de fen\u00eatre officielle est Swing. Toutefois, AWT sert encore de fondement \u00e0 Swing, dans la mesure o\u00f9 de nombreuses classes Swing h\u00e9ritent de classes AWT. AWT permet notamment la cr\u00e9ation d'objets graphiques pr\u00e9con\u00e7us tel que des boutons, des sliders ou encore des menus d\u00e9roulants. Dimensionnement des composants En g\u00e9n\u00e9ral, le dimensionnement des composants est automatique gr\u00e2ce au LayoutManager . Pour donner \u00e0 un composant une taille donn\u00e9e, il faut red\u00e9finir la m\u00e9thopde getPreferedSize() de la classe Component . Dimensionnement des composants Code 1 2 3 4 5 6 public class CustomButton extends Button { @Override public Dimension getPreferredSize () { return new Dimension ( 800 , 250 ); } } Commentaire La m\u00e9thode getPreferedSize() indique la taille souhait\u00e9e mais pas celle impos\u00e9e. En fonction du LayoutManager, le composant pourra ou non imposer sa taille. Cette m\u00e9thode oblige \u00e0 sous-classer tous les composants. Une autre fa\u00e7on de faire est de se passer des Layout et de placer les composants \u00e0 la main en indiquant leurs coordonn\u00e9es et leurs dimensions. Pour supprimer le Layout par d\u00e9faut d'une classe, il faut appeler la m\u00e9thode setLayout() avec comme param\u00e8tre null. Trois m\u00e9thodes de la classe Component permettent de positionner des composants \u00e0 la position (x,y) par rapport au conteur dans lequel il est inclus et d'indiquer sa largeur et sa hauteur : setBounds(int x, int y, int largeur, int hauteur) , setLocation(int x , int y) et setSize(int largeur, int hauteur) . Posionnement des composants Lorqu'un composant graphique est int\u00e9gr\u00e9 dans un conteneur, son emplacement est determin\u00e9 de fa\u00e7on automatique : La mise en forme est dynamique. Cependant, un layout manager peut \u00eatre utilis\u00e9 pour d\u00e9finir la position de chaque \u00e9l\u00e9ment ins\u00e9r\u00e9. Dans ce cas, la position sp\u00e9cifi\u00e9e est relative aux autres composants. Chaque layout manager impl\u00e9mente l'interface java.awt.LayoutManager. Pour affecter un LayoutManager, il faut faire appel \u00e0 la m\u00e9thode setLayout() de la classe Container . Appel \u00e0 setLayout() Code 1 2 Panel panel = new Panel (); panel . setLayout ( new GridLayout ( 5 , 5 )); Pour cr\u00e9er un espace entre les composants et le bord de leur conteneur, il faut red\u00e9finir la m\u00e9thode getInsets() de la classe Container . Red\u00e9finition de getInsets() Code 1 2 3 4 5 6 7 @Override public Insets getInsets () { Insets normal = super . getInsets (); // Cet exemple permet de laisser 10 pixels en plus entre chaque bords du conteneur. return new Insets ( normal . top + 10 , normal . left + 10 , normal . bottom + 10 , normal . right + 10 ); }","title":"Whatisswing"},{"location":"java/swing/whatisswing/#quest-ce-que-swing","text":"Abstract Window Toolkit (AWT) est une biblioth\u00e8que graphique pour Java, faisant partie de Java Foundation Classes (JFC) . Cette biblioth\u00e8que a \u00e9t\u00e9 introduite d\u00e8s les premi\u00e8res versions de Java (depuis Java 2), la biblioth\u00e8que de gestion de fen\u00eatre officielle est Swing. Toutefois, AWT sert encore de fondement \u00e0 Swing, dans la mesure o\u00f9 de nombreuses classes Swing h\u00e9ritent de classes AWT. AWT permet notamment la cr\u00e9ation d'objets graphiques pr\u00e9con\u00e7us tel que des boutons, des sliders ou encore des menus d\u00e9roulants.","title":"Qu'est-ce que Swing ?"},{"location":"java/swing/whatisswing/#dimensionnement-des-composants","text":"En g\u00e9n\u00e9ral, le dimensionnement des composants est automatique gr\u00e2ce au LayoutManager . Pour donner \u00e0 un composant une taille donn\u00e9e, il faut red\u00e9finir la m\u00e9thopde getPreferedSize() de la classe Component . Dimensionnement des composants Code 1 2 3 4 5 6 public class CustomButton extends Button { @Override public Dimension getPreferredSize () { return new Dimension ( 800 , 250 ); } } Commentaire La m\u00e9thode getPreferedSize() indique la taille souhait\u00e9e mais pas celle impos\u00e9e. En fonction du LayoutManager, le composant pourra ou non imposer sa taille. Cette m\u00e9thode oblige \u00e0 sous-classer tous les composants. Une autre fa\u00e7on de faire est de se passer des Layout et de placer les composants \u00e0 la main en indiquant leurs coordonn\u00e9es et leurs dimensions. Pour supprimer le Layout par d\u00e9faut d'une classe, il faut appeler la m\u00e9thode setLayout() avec comme param\u00e8tre null. Trois m\u00e9thodes de la classe Component permettent de positionner des composants \u00e0 la position (x,y) par rapport au conteur dans lequel il est inclus et d'indiquer sa largeur et sa hauteur : setBounds(int x, int y, int largeur, int hauteur) , setLocation(int x , int y) et setSize(int largeur, int hauteur) .","title":"Dimensionnement des composants"},{"location":"java/swing/whatisswing/#posionnement-des-composants","text":"Lorqu'un composant graphique est int\u00e9gr\u00e9 dans un conteneur, son emplacement est determin\u00e9 de fa\u00e7on automatique : La mise en forme est dynamique. Cependant, un layout manager peut \u00eatre utilis\u00e9 pour d\u00e9finir la position de chaque \u00e9l\u00e9ment ins\u00e9r\u00e9. Dans ce cas, la position sp\u00e9cifi\u00e9e est relative aux autres composants. Chaque layout manager impl\u00e9mente l'interface java.awt.LayoutManager. Pour affecter un LayoutManager, il faut faire appel \u00e0 la m\u00e9thode setLayout() de la classe Container . Appel \u00e0 setLayout() Code 1 2 Panel panel = new Panel (); panel . setLayout ( new GridLayout ( 5 , 5 )); Pour cr\u00e9er un espace entre les composants et le bord de leur conteneur, il faut red\u00e9finir la m\u00e9thode getInsets() de la classe Container . Red\u00e9finition de getInsets() Code 1 2 3 4 5 6 7 @Override public Insets getInsets () { Insets normal = super . getInsets (); // Cet exemple permet de laisser 10 pixels en plus entre chaque bords du conteneur. return new Insets ( normal . top + 10 , normal . left + 10 , normal . bottom + 10 , normal . right + 10 ); }","title":"Posionnement des composants"},{"location":"poo/introduction/","text":"Introduction Qu'est-ce que la POO ? La Programmation Orient\u00e9e Objet (POO) est un paradigme de programmation informatique. Elle consiste \u00e0 d\u00e9finir des briques logicielles appel\u00e9es objets . Tout est alors consid\u00e9r\u00e9 comme objet : Un concept Une id\u00e9e Une musique Une entit\u00e9 du monde physique Un nombre complexe Une figure g\u00e9om\u00e9trique ... L'objectif est de d\u00e9finir et faire int\u00e9ragir entre eux ces objets. L'un des avantages de la POO est de masquer la complexit\u00e9 du code \u00e0 l'utilisateur.","title":"Introduction"},{"location":"poo/introduction/#introduction","text":"","title":"Introduction"},{"location":"poo/introduction/#quest-ce-que-la-poo","text":"La Programmation Orient\u00e9e Objet (POO) est un paradigme de programmation informatique. Elle consiste \u00e0 d\u00e9finir des briques logicielles appel\u00e9es objets . Tout est alors consid\u00e9r\u00e9 comme objet : Un concept Une id\u00e9e Une musique Une entit\u00e9 du monde physique Un nombre complexe Une figure g\u00e9om\u00e9trique ... L'objectif est de d\u00e9finir et faire int\u00e9ragir entre eux ces objets. L'un des avantages de la POO est de masquer la complexit\u00e9 du code \u00e0 l'utilisateur.","title":"Qu'est-ce que la POO ?"},{"location":"poo/poo/","text":"Les principes de la POO Les classes Comme dit dans l'introduction, la programmation orient\u00e9e objet consiste \u00e0 cr\u00e9er des briques logicielles appel\u00e9es objets . Un objet est mat\u00e9rialis\u00e9 par une ou plusieurs classes, qui peuvent \u00eatre facilement r\u00e9utilis\u00e9es et modifiables. En fait, on dit qu' un objet est une instance d'une classe . Une classe est constitu\u00e9e \u00e0 minima : De variables, appel\u00e9es attributs qui d\u00e9crivent comment est mod\u00e9lis\u00e9 l'objet. De fonctions, appel\u00e9es m\u00e9thodes qui permettent d'effectuer des actions sur l'objet. Une classe peut \u00e9galement poss\u00e9der : Des mutateurs ( getters et setters ) qui permettent de r\u00e9cup\u00e9rer ou modifier les valeurs des attributs. Une ou plusieurs fonctions particuli\u00e8res, appel\u00e9es constructeurs , qui permettent d'instancier (cr\u00e9er) un objet en lui allouant la m\u00e9moire n\u00e9cessaire et en y initialisant ses attributs. Exemple : Java Utilisateur.java public class Utilisateur { // Attributs private int id ; private int age ; private String name ; private String emailAddress ; // Constructeur par d\u00e9faut public Utilisateur () { } // Constructeur avec param\u00e8tres public Utilisateur ( int id , int age , String name , String emailAddress ){ this . id = id ; this . age = age ; this . name = name ; this . emailAddress = emailAddress ; } // Setters public void setIdentifiant ( int identifiant ){ this . identifiant = identifiant ; } public void setAge ( int age ){ this . age = age ; } public void setName ( String name ){ this . name = name ; } public void setEmailAddress ( String emailAddress ){ this . emailAddress = emailAddress ; } // Getters public int getIdentifiant (){ return this . identifiant ; } public int getAge (){ return this . age ; } public String getName (){ return this . name ; } public String getEmailAddress (){ return this . emailAddress ; } // Exemple d'une m\u00e9thode public boolean isAdult () { return ( this . age >= 18 ); } } Main.java public class Main { public static void main ( String [] args ) { // Cr\u00e9ation d'une instance d'un utilisateur Utilisateur utilisateur = new Utilisateur ( 0 , 17 , \"Marc\" , \"marc.email@domain.com\" ); utilisateur . isAdult (); // Renvoie false } } C++ Utilisateur.h #ifndef UTILISATEUR_H #define UTILISATEUR_H #include <string.h> using namespace std ; class Utilisateur { private : // Attributs int identifiant ; int age ; string name ; string emailAddress ; public : // Constructeur par d\u00e9faut Utilisateur (); // Constructeur avec param\u00e8tres Utilisateur ( int identifiant , int age , string name , string emailAddress ); // Setters void setIdentifiant ( int identifiant ); void setAge ( int age ); void setName ( string name ); void setEmailAddress ( string emailAddress ); // Getters int getIdentifiant (); int getAge (); string getName (); string getEmailAddress ; // Example d'une m\u00e9thode bool isAdult (); }; #endif Utilisateur.cpp #include \"Utilisateur.h\" #include <string> using namespace std ; // Impl\u00e9mentation du constructeur par d\u00e9faut Utilisateur :: Utilisateur () : { } // Impl\u00e9mentation du constructeur avec param\u00e8tres Utilisateur :: Utilisateur ( int identifiant , int age , string name , string emailAddress ) : { this -> identifiant = identifiant ; this -> age = age ; this -> name = name ; this . emailAddress = emailAddress ; } // Impl\u00e9mentation des setters void Utilisateur :: setIdentifiant ( int identifiant ){ this -> identifiant = identifiant ; } void Utilisateur : setAge ( int age ){ this -> age = age ; } void Utilisateur :: setName ( string name ){ this -> name = name ; } void Utilisateur :: setEmailAddress ( string emailAddress ){ this -> emailAddress = emailAddress ; } // Impl\u00e9mentation des getters int Utilisateur :: getIdentifiant (){ return this -> identifiant ; } int Utilisateur :: getAge (){ return this -> age ; } string Utilisateur :: getName (){ return this -> name ; } string Utilisateur :: getEmailAddress (){ return this -> emailAddress ; } // Impl\u00e9mentation des m\u00e9thodes bool Utilisateur :: isAdult (){ return ( this -> age >= 18 ); } Main.cpp #include <string> using namespace std ; #include \"Utilisateur.h\" int main () { Utilisateur * utilisateur = new Utilisateur ( 0 , 17 , \"Marc\" , \"marc.email@domain.com\" ); utilisateur -> isAdult () // Renvoie false delete utilisateur ; return 0 ; } L'exemple ci-dessus repr\u00e9sente un utilisateur qui poss\u00e8de comme attributs : Un identifiant (nombre entier) Un \u00e2ge (nombre entier) Un nom (cha\u00eene de caract\u00e8res) Une addresse email (cha\u00eene de caract\u00e8res) Pour instancier un utilisateur, on utilise l'un des deux constructeurs : Par d\u00e9faut (Ici, le constructeur par d\u00e9faut n'initialise pas les valeurs. En Java, le compiler va initialiser par d\u00e9faut les int \u00e0 0 et les String \u00e0 null. M\u00eame chose en C++). Avec param\u00e8tres : Le mot cl\u00e9 this permet de faire r\u00e9f\u00e9rence \u00e0 l'objet en cours pour initialiser ses valeurs. Notre classe Utilisateur poss\u00e8de \u00e9galement une m\u00e9thode isAdult qui retourne un bool\u00e9en. Que ce soit en C++ ou en Java, vous l'aurez remarqu\u00e9, la pr\u00e9sence de mots cl\u00e9s comme public ou private : Cela nous m\u00e8ne donc \u00e0 un autre concept important d'un langage orient\u00e9 objet : L'encapsulation des donn\u00e9es L'encapsulation des donn\u00e9es L'encapsulation est un m\u00e9canisme consistant \u00e0 rassembler les attributs et les m\u00e9thodes au sein d'une structure en limitant par d\u00e9faut le champ d'action de ces attributs et m\u00e9thodes \u00e0 l'objet lui-m\u00eame et non \u00e0 tout autre objet. L'encapsulation permet de d\u00e9finir des niveaux de visibilit\u00e9 des \u00e9l\u00e9ments de la classe. Ces niveaux de visibilit\u00e9 d\u00e9finissent les droits d'acc\u00e8s aux donn\u00e9es selon que l'on y acc\u00e8de par une m\u00e9thode de la classe elle-m\u00eame, d'une classe h\u00e9rit\u00e8re, ou bien d'une classe quelconque. Il existe trois niveaux de visibilit\u00e9 : Publique : Un membre (attribut, m\u00e9thode ...) publique sera accessible de n'importe o\u00f9 dans le programme. La classe a donc acc\u00e8s \u00e0 ce membre, mais aussi n'importe quelle autre classe. Priv\u00e9 : Seul la classe ayant d\u00e9finit le membre priv\u00e9 pourra y acc\u00e9der. Prot\u00e9g\u00e9 : Un membre prot\u00e9g\u00e9 peut \u00eatre manipul\u00e9 : Dans la classe qui d\u00e9finit ce membre Dans les classes qui h\u00e9ritent de la classe consid\u00e9r\u00e9e Particularit\u00e9 pour Java : Dans les classes et les types d\u00e9finies dans le m\u00eame package que celle qui d\u00e9finit le membre prot\u00e9g\u00e9 (On ne retrouve pas cette notion en C++ avec la notion de namespaces) H\u00e9ritage L'h\u00e9ritage est un autre principe de la programmation orient\u00e9e objet, permettant de cr\u00e9er une nouvelle classe \u00e0 partir d'une classe existante. La classe h\u00e9rit\u00e9e a alors acc\u00e8s aux membres publiques et prot\u00e9g\u00e9s de sa superclasse (classe dont elle d\u00e9rive). L'h\u00e9ritage peut \u00eatre traduit en fran\u00e7ais par \" est une sorte de \". Par exemple, on peut dire qu'une voiture est une sorte de v\u00e9hicule. On peut donc imaginer une classe V\u00e9hicule, et une classe Voiture qui h\u00e9rite de la classe V\u00e9hicule : Java Vehicule.java public class Vehicule { // Attributs private float vitesse ; private int nombreDePlaces ; // Constructeur par d\u00e9faut public Vehicule () { super (); } // Constructeur avec param\u00e8tres public Vehicule ( float vitesse , int nombreDePlace ){ this . vitesse = vitesse ; this . nombreDePlace = nombreDePlace ; } // Setters public void setVitesse ( float vitesse ){ this . vitesse = vitesse ; } public void setNombreDePlace ( int nombreDePlace ){ this . nombreDePlace = nombreDePlace ; } // Getters public float getVitesse (){ return this . vitesse ; } public int getNombreDePlace (){ return this . nombreDePlace ; } // M\u00e9thodes protected boolean nombreDePlaceEstPair (){ return ( this . nombreDePlace % 2 == 0 ); } private boolean vitesseEstNulle () { return ( this . vitesse == 0.0f ); } } Voiture.java // La classe Voiture h\u00e9rite de la classe Vehicule : mot cl\u00e9 extends public class Voiture extends Vehicule { // Attributs private String marque ; private String typeMoteur ; // Constructeur par d\u00e9faut public Voiture () { // Ici, super() fait appel au constructeur par d\u00e9faut de la classe Vehicule super (); } // Constructeur avec param\u00e8tres public Voiture ( int vitesse , int nombreDePlace , String marque , String typeMoteur ){ // Ici, super(...) fait appel au constructeur avec param\u00e8tres de la classe V\u00e9hicule super ( vitesse , nombreDePlace ); this . marque = marque ; this . typeMoteur = typeMoteur ; } // Setters public void setMarque ( float marque ){ this . marque = marque ; } public void setTypeMoteur ( int typeMoteur ){ this . typeMoteur = typeMoteur ; } // Getters public float getMarque (){ return this . marque ; } public int getTypeMoteur (){ return this . typeMoteur ; } /* M\u00e9thodes : @Override permet de signaler qu'il s'agit d'une m\u00e9thode de la classe m\u00e8re qu'on surcharge. On peut \u00e9galement noter que dans la classe m\u00e8re, la m\u00e9thode est prot\u00e9g\u00e9e, et elle devient publique ici. Il s'agit d'une particularit\u00e9 de l'encapsulation : On peut modifier la visibilit\u00e9 si celle-ci devient moins restrictive. On aurait donc pas pu d\u00e9finir la m\u00e9thode comme \u00e9tant priv\u00e9 i\u00e7i par exemple. */ @Override public boolean nombreDePlaceEstPair () { return ( super . getNombreDePlace () % 2 == 0 ? true : false ); } } Main.java public class Main { public static void main ( String [] args ) { Voiture voiture1 = new Voiture ( 70 , 4 , \"BMW\" , \"Essence\" ); // Une voiture est une sorte de v\u00e9hicule, on peut donc cr\u00e9er un Objet Vehicule qui est une instance de Voiture. Vehicule voiture2 = new Voiture (); } } C++ On peut noter la pr\u00e9sence du mot cl\u00e9 : super , parfois super() . super permet de faire r\u00e9f\u00e9rence \u00e0 l'objet parent. Ainsi, super.getNombreDePlace() permet de r\u00e9cup\u00e9rer le nombre de place du parent. super() permet de faire appel au constructeur par d\u00e9faut de l'objet parent. Ainsi, le super() du constructeur par d\u00e9faut de Voiture va faire appel au constructeur par d\u00e9faut de V\u00e9hicule. On peut cependant noter la pr\u00e9sence de super() dans le constructeur par d\u00e9faut de Vehicule en Java, pourtant cette classe n'h\u00e9rite d'aucune classe ! Et bien... si ! En Java, toutes les classes cr\u00e9\u00e9es h\u00e9ritent d'une classe nomm\u00e9 Object ! On peut \u00e9galement faire appel \u00e0 des constructeurs avec param\u00e8tres en les rajoutant dans super(...) .","title":"Les principes de la POO"},{"location":"poo/poo/#les-principes-de-la-poo","text":"","title":"Les principes de la POO"},{"location":"poo/poo/#les-classes","text":"Comme dit dans l'introduction, la programmation orient\u00e9e objet consiste \u00e0 cr\u00e9er des briques logicielles appel\u00e9es objets . Un objet est mat\u00e9rialis\u00e9 par une ou plusieurs classes, qui peuvent \u00eatre facilement r\u00e9utilis\u00e9es et modifiables. En fait, on dit qu' un objet est une instance d'une classe . Une classe est constitu\u00e9e \u00e0 minima : De variables, appel\u00e9es attributs qui d\u00e9crivent comment est mod\u00e9lis\u00e9 l'objet. De fonctions, appel\u00e9es m\u00e9thodes qui permettent d'effectuer des actions sur l'objet. Une classe peut \u00e9galement poss\u00e9der : Des mutateurs ( getters et setters ) qui permettent de r\u00e9cup\u00e9rer ou modifier les valeurs des attributs. Une ou plusieurs fonctions particuli\u00e8res, appel\u00e9es constructeurs , qui permettent d'instancier (cr\u00e9er) un objet en lui allouant la m\u00e9moire n\u00e9cessaire et en y initialisant ses attributs. Exemple : Java Utilisateur.java public class Utilisateur { // Attributs private int id ; private int age ; private String name ; private String emailAddress ; // Constructeur par d\u00e9faut public Utilisateur () { } // Constructeur avec param\u00e8tres public Utilisateur ( int id , int age , String name , String emailAddress ){ this . id = id ; this . age = age ; this . name = name ; this . emailAddress = emailAddress ; } // Setters public void setIdentifiant ( int identifiant ){ this . identifiant = identifiant ; } public void setAge ( int age ){ this . age = age ; } public void setName ( String name ){ this . name = name ; } public void setEmailAddress ( String emailAddress ){ this . emailAddress = emailAddress ; } // Getters public int getIdentifiant (){ return this . identifiant ; } public int getAge (){ return this . age ; } public String getName (){ return this . name ; } public String getEmailAddress (){ return this . emailAddress ; } // Exemple d'une m\u00e9thode public boolean isAdult () { return ( this . age >= 18 ); } } Main.java public class Main { public static void main ( String [] args ) { // Cr\u00e9ation d'une instance d'un utilisateur Utilisateur utilisateur = new Utilisateur ( 0 , 17 , \"Marc\" , \"marc.email@domain.com\" ); utilisateur . isAdult (); // Renvoie false } } C++ Utilisateur.h #ifndef UTILISATEUR_H #define UTILISATEUR_H #include <string.h> using namespace std ; class Utilisateur { private : // Attributs int identifiant ; int age ; string name ; string emailAddress ; public : // Constructeur par d\u00e9faut Utilisateur (); // Constructeur avec param\u00e8tres Utilisateur ( int identifiant , int age , string name , string emailAddress ); // Setters void setIdentifiant ( int identifiant ); void setAge ( int age ); void setName ( string name ); void setEmailAddress ( string emailAddress ); // Getters int getIdentifiant (); int getAge (); string getName (); string getEmailAddress ; // Example d'une m\u00e9thode bool isAdult (); }; #endif Utilisateur.cpp #include \"Utilisateur.h\" #include <string> using namespace std ; // Impl\u00e9mentation du constructeur par d\u00e9faut Utilisateur :: Utilisateur () : { } // Impl\u00e9mentation du constructeur avec param\u00e8tres Utilisateur :: Utilisateur ( int identifiant , int age , string name , string emailAddress ) : { this -> identifiant = identifiant ; this -> age = age ; this -> name = name ; this . emailAddress = emailAddress ; } // Impl\u00e9mentation des setters void Utilisateur :: setIdentifiant ( int identifiant ){ this -> identifiant = identifiant ; } void Utilisateur : setAge ( int age ){ this -> age = age ; } void Utilisateur :: setName ( string name ){ this -> name = name ; } void Utilisateur :: setEmailAddress ( string emailAddress ){ this -> emailAddress = emailAddress ; } // Impl\u00e9mentation des getters int Utilisateur :: getIdentifiant (){ return this -> identifiant ; } int Utilisateur :: getAge (){ return this -> age ; } string Utilisateur :: getName (){ return this -> name ; } string Utilisateur :: getEmailAddress (){ return this -> emailAddress ; } // Impl\u00e9mentation des m\u00e9thodes bool Utilisateur :: isAdult (){ return ( this -> age >= 18 ); } Main.cpp #include <string> using namespace std ; #include \"Utilisateur.h\" int main () { Utilisateur * utilisateur = new Utilisateur ( 0 , 17 , \"Marc\" , \"marc.email@domain.com\" ); utilisateur -> isAdult () // Renvoie false delete utilisateur ; return 0 ; } L'exemple ci-dessus repr\u00e9sente un utilisateur qui poss\u00e8de comme attributs : Un identifiant (nombre entier) Un \u00e2ge (nombre entier) Un nom (cha\u00eene de caract\u00e8res) Une addresse email (cha\u00eene de caract\u00e8res) Pour instancier un utilisateur, on utilise l'un des deux constructeurs : Par d\u00e9faut (Ici, le constructeur par d\u00e9faut n'initialise pas les valeurs. En Java, le compiler va initialiser par d\u00e9faut les int \u00e0 0 et les String \u00e0 null. M\u00eame chose en C++). Avec param\u00e8tres : Le mot cl\u00e9 this permet de faire r\u00e9f\u00e9rence \u00e0 l'objet en cours pour initialiser ses valeurs. Notre classe Utilisateur poss\u00e8de \u00e9galement une m\u00e9thode isAdult qui retourne un bool\u00e9en. Que ce soit en C++ ou en Java, vous l'aurez remarqu\u00e9, la pr\u00e9sence de mots cl\u00e9s comme public ou private : Cela nous m\u00e8ne donc \u00e0 un autre concept important d'un langage orient\u00e9 objet : L'encapsulation des donn\u00e9es","title":"Les classes"},{"location":"poo/poo/#lencapsulation-des-donnees","text":"L'encapsulation est un m\u00e9canisme consistant \u00e0 rassembler les attributs et les m\u00e9thodes au sein d'une structure en limitant par d\u00e9faut le champ d'action de ces attributs et m\u00e9thodes \u00e0 l'objet lui-m\u00eame et non \u00e0 tout autre objet. L'encapsulation permet de d\u00e9finir des niveaux de visibilit\u00e9 des \u00e9l\u00e9ments de la classe. Ces niveaux de visibilit\u00e9 d\u00e9finissent les droits d'acc\u00e8s aux donn\u00e9es selon que l'on y acc\u00e8de par une m\u00e9thode de la classe elle-m\u00eame, d'une classe h\u00e9rit\u00e8re, ou bien d'une classe quelconque. Il existe trois niveaux de visibilit\u00e9 : Publique : Un membre (attribut, m\u00e9thode ...) publique sera accessible de n'importe o\u00f9 dans le programme. La classe a donc acc\u00e8s \u00e0 ce membre, mais aussi n'importe quelle autre classe. Priv\u00e9 : Seul la classe ayant d\u00e9finit le membre priv\u00e9 pourra y acc\u00e9der. Prot\u00e9g\u00e9 : Un membre prot\u00e9g\u00e9 peut \u00eatre manipul\u00e9 : Dans la classe qui d\u00e9finit ce membre Dans les classes qui h\u00e9ritent de la classe consid\u00e9r\u00e9e Particularit\u00e9 pour Java : Dans les classes et les types d\u00e9finies dans le m\u00eame package que celle qui d\u00e9finit le membre prot\u00e9g\u00e9 (On ne retrouve pas cette notion en C++ avec la notion de namespaces)","title":"L'encapsulation des donn\u00e9es"},{"location":"poo/poo/#heritage","text":"L'h\u00e9ritage est un autre principe de la programmation orient\u00e9e objet, permettant de cr\u00e9er une nouvelle classe \u00e0 partir d'une classe existante. La classe h\u00e9rit\u00e9e a alors acc\u00e8s aux membres publiques et prot\u00e9g\u00e9s de sa superclasse (classe dont elle d\u00e9rive). L'h\u00e9ritage peut \u00eatre traduit en fran\u00e7ais par \" est une sorte de \". Par exemple, on peut dire qu'une voiture est une sorte de v\u00e9hicule. On peut donc imaginer une classe V\u00e9hicule, et une classe Voiture qui h\u00e9rite de la classe V\u00e9hicule : Java Vehicule.java public class Vehicule { // Attributs private float vitesse ; private int nombreDePlaces ; // Constructeur par d\u00e9faut public Vehicule () { super (); } // Constructeur avec param\u00e8tres public Vehicule ( float vitesse , int nombreDePlace ){ this . vitesse = vitesse ; this . nombreDePlace = nombreDePlace ; } // Setters public void setVitesse ( float vitesse ){ this . vitesse = vitesse ; } public void setNombreDePlace ( int nombreDePlace ){ this . nombreDePlace = nombreDePlace ; } // Getters public float getVitesse (){ return this . vitesse ; } public int getNombreDePlace (){ return this . nombreDePlace ; } // M\u00e9thodes protected boolean nombreDePlaceEstPair (){ return ( this . nombreDePlace % 2 == 0 ); } private boolean vitesseEstNulle () { return ( this . vitesse == 0.0f ); } } Voiture.java // La classe Voiture h\u00e9rite de la classe Vehicule : mot cl\u00e9 extends public class Voiture extends Vehicule { // Attributs private String marque ; private String typeMoteur ; // Constructeur par d\u00e9faut public Voiture () { // Ici, super() fait appel au constructeur par d\u00e9faut de la classe Vehicule super (); } // Constructeur avec param\u00e8tres public Voiture ( int vitesse , int nombreDePlace , String marque , String typeMoteur ){ // Ici, super(...) fait appel au constructeur avec param\u00e8tres de la classe V\u00e9hicule super ( vitesse , nombreDePlace ); this . marque = marque ; this . typeMoteur = typeMoteur ; } // Setters public void setMarque ( float marque ){ this . marque = marque ; } public void setTypeMoteur ( int typeMoteur ){ this . typeMoteur = typeMoteur ; } // Getters public float getMarque (){ return this . marque ; } public int getTypeMoteur (){ return this . typeMoteur ; } /* M\u00e9thodes : @Override permet de signaler qu'il s'agit d'une m\u00e9thode de la classe m\u00e8re qu'on surcharge. On peut \u00e9galement noter que dans la classe m\u00e8re, la m\u00e9thode est prot\u00e9g\u00e9e, et elle devient publique ici. Il s'agit d'une particularit\u00e9 de l'encapsulation : On peut modifier la visibilit\u00e9 si celle-ci devient moins restrictive. On aurait donc pas pu d\u00e9finir la m\u00e9thode comme \u00e9tant priv\u00e9 i\u00e7i par exemple. */ @Override public boolean nombreDePlaceEstPair () { return ( super . getNombreDePlace () % 2 == 0 ? true : false ); } } Main.java public class Main { public static void main ( String [] args ) { Voiture voiture1 = new Voiture ( 70 , 4 , \"BMW\" , \"Essence\" ); // Une voiture est une sorte de v\u00e9hicule, on peut donc cr\u00e9er un Objet Vehicule qui est une instance de Voiture. Vehicule voiture2 = new Voiture (); } } C++ On peut noter la pr\u00e9sence du mot cl\u00e9 : super , parfois super() . super permet de faire r\u00e9f\u00e9rence \u00e0 l'objet parent. Ainsi, super.getNombreDePlace() permet de r\u00e9cup\u00e9rer le nombre de place du parent. super() permet de faire appel au constructeur par d\u00e9faut de l'objet parent. Ainsi, le super() du constructeur par d\u00e9faut de Voiture va faire appel au constructeur par d\u00e9faut de V\u00e9hicule. On peut cependant noter la pr\u00e9sence de super() dans le constructeur par d\u00e9faut de Vehicule en Java, pourtant cette classe n'h\u00e9rite d'aucune classe ! Et bien... si ! En Java, toutes les classes cr\u00e9\u00e9es h\u00e9ritent d'une classe nomm\u00e9 Object ! On peut \u00e9galement faire appel \u00e0 des constructeurs avec param\u00e8tres en les rajoutant dans super(...) .","title":"H\u00e9ritage"}]}